// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "../yardl/detail/ndjson/serializers.h"
#include "protocols.h"

namespace petsird {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, petsird::CoincidenceEvent const& value);
void from_json(ordered_json const& j, petsird::CoincidenceEvent& value);

template <typename Shape>
void to_json(ordered_json& j, petsird::SolidVolume<Shape> const& value);
template <typename Shape>
void from_json(ordered_json const& j, petsird::SolidVolume<Shape>& value);

void to_json(ordered_json& j, petsird::Coordinate const& value);
void from_json(ordered_json const& j, petsird::Coordinate& value);

void to_json(ordered_json& j, petsird::BoxShape const& value);
void from_json(ordered_json const& j, petsird::BoxShape& value);

void to_json(ordered_json& j, petsird::AnnulusShape const& value);
void from_json(ordered_json const& j, petsird::AnnulusShape& value);

void to_json(ordered_json& j, petsird::RigidTransformation const& value);
void from_json(ordered_json const& j, petsird::RigidTransformation& value);

template <typename T>
void to_json(ordered_json& j, petsird::ReplicatedObject<T> const& value);
template <typename T>
void from_json(ordered_json const& j, petsird::ReplicatedObject<T>& value);

void to_json(ordered_json& j, petsird::DetectorModule const& value);
void from_json(ordered_json const& j, petsird::DetectorModule& value);

void to_json(ordered_json& j, petsird::ScannerGeometry const& value);
void from_json(ordered_json const& j, petsird::ScannerGeometry& value);

void to_json(ordered_json& j, petsird::Subject const& value);
void from_json(ordered_json const& j, petsird::Subject& value);

void to_json(ordered_json& j, petsird::Institution const& value);
void from_json(ordered_json const& j, petsird::Institution& value);

void to_json(ordered_json& j, petsird::ExamInformation const& value);
void from_json(ordered_json const& j, petsird::ExamInformation& value);

void to_json(ordered_json& j, petsird::Direction const& value);
void from_json(ordered_json const& j, petsird::Direction& value);

void to_json(ordered_json& j, petsird::DirectionMatrix const& value);
void from_json(ordered_json const& j, petsird::DirectionMatrix& value);

void to_json(ordered_json& j, petsird::Atom const& value);
void from_json(ordered_json const& j, petsird::Atom& value);

void to_json(ordered_json& j, petsird::BulkMaterial const& value);
void from_json(ordered_json const& j, petsird::BulkMaterial& value);

void to_json(ordered_json& j, petsird::CoincidencePolicy const& value);
void from_json(ordered_json const& j, petsird::CoincidencePolicy& value);

void to_json(ordered_json& j, petsird::ScannerInformation const& value);
void from_json(ordered_json const& j, petsird::ScannerInformation& value);

void to_json(ordered_json& j, petsird::Header const& value);
void from_json(ordered_json const& j, petsird::Header& value);

void to_json(ordered_json& j, petsird::TripleEvent const& value);
void from_json(ordered_json const& j, petsird::TripleEvent& value);

void to_json(ordered_json& j, petsird::EventTimeBlock const& value);
void from_json(ordered_json const& j, petsird::EventTimeBlock& value);

void to_json(ordered_json& j, petsird::ExternalSignalTimeBlock const& value);
void from_json(ordered_json const& j, petsird::ExternalSignalTimeBlock& value);

void to_json(ordered_json& j, petsird::BedMovementTimeBlock const& value);
void from_json(ordered_json const& j, petsird::BedMovementTimeBlock& value);

void to_json(ordered_json& j, petsird::GantryMovementTimeBlock const& value);
void from_json(ordered_json const& j, petsird::GantryMovementTimeBlock& value);

void to_json(ordered_json& j, petsird::ExternalSignalTypeEnum const& value);
void from_json(ordered_json const& j, petsird::ExternalSignalTypeEnum& value);

void to_json(ordered_json& j, petsird::ExternalSignalType const& value);
void from_json(ordered_json const& j, petsird::ExternalSignalType& value);

void to_json(ordered_json& j, petsird::TimeInterval const& value);
void from_json(ordered_json const& j, petsird::TimeInterval& value);

void to_json(ordered_json& j, petsird::TimeFrameInformation const& value);
void from_json(ordered_json const& j, petsird::TimeFrameInformation& value);

} // namespace petsird

NLOHMANN_JSON_NAMESPACE_BEGIN

template <>
struct adl_serializer<std::variant<petsird::BoxShape, petsird::AnnulusShape>> {
  static void to_json(ordered_json& j, std::variant<petsird::BoxShape, petsird::AnnulusShape> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"BoxShape", std::get<petsird::BoxShape>(value)} };
        break;
      case 1:
        j = ordered_json{ {"AnnulusShape", std::get<petsird::AnnulusShape>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<petsird::BoxShape, petsird::AnnulusShape>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "BoxShape") {
      value = it.value().get<petsird::BoxShape>();
      return;
    }
    if (tag == "AnnulusShape") {
      value = it.value().get<petsird::AnnulusShape>();
      return;
    }
  }
};

template <>
struct adl_serializer<std::variant<petsird::EventTimeBlock, petsird::ExternalSignalTimeBlock, petsird::BedMovementTimeBlock, petsird::GantryMovementTimeBlock>> {
  static void to_json(ordered_json& j, std::variant<petsird::EventTimeBlock, petsird::ExternalSignalTimeBlock, petsird::BedMovementTimeBlock, petsird::GantryMovementTimeBlock> const& value) {
    switch (value.index()) {
      case 0:
        j = ordered_json{ {"EventTimeBlock", std::get<petsird::EventTimeBlock>(value)} };
        break;
      case 1:
        j = ordered_json{ {"ExternalSignalTimeBlock", std::get<petsird::ExternalSignalTimeBlock>(value)} };
        break;
      case 2:
        j = ordered_json{ {"BedMovementTimeBlock", std::get<petsird::BedMovementTimeBlock>(value)} };
        break;
      case 3:
        j = ordered_json{ {"GantryMovementTimeBlock", std::get<petsird::GantryMovementTimeBlock>(value)} };
        break;
      default:
        throw std::runtime_error("Invalid union value");
    }
  }

  static void from_json(ordered_json const& j, std::variant<petsird::EventTimeBlock, petsird::ExternalSignalTimeBlock, petsird::BedMovementTimeBlock, petsird::GantryMovementTimeBlock>& value) {
    auto it = j.begin();
    std::string tag = it.key();
    if (tag == "EventTimeBlock") {
      value = it.value().get<petsird::EventTimeBlock>();
      return;
    }
    if (tag == "ExternalSignalTimeBlock") {
      value = it.value().get<petsird::ExternalSignalTimeBlock>();
      return;
    }
    if (tag == "BedMovementTimeBlock") {
      value = it.value().get<petsird::BedMovementTimeBlock>();
      return;
    }
    if (tag == "GantryMovementTimeBlock") {
      value = it.value().get<petsird::GantryMovementTimeBlock>();
      return;
    }
  }
};

NLOHMANN_JSON_NAMESPACE_END

namespace petsird {
using ordered_json = nlohmann::ordered_json;

void to_json(ordered_json& j, petsird::CoincidenceEvent const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.detector_ids)) {
    j.push_back({"detectorIds", value.detector_ids});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.tof_idx)) {
    j.push_back({"tofIdx", value.tof_idx});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.energy_indices)) {
    j.push_back({"energyIndices", value.energy_indices});
  }
}

void from_json(ordered_json const& j, petsird::CoincidenceEvent& value) {
  if (auto it = j.find("detectorIds"); it != j.end()) {
    it->get_to(value.detector_ids);
  }
  if (auto it = j.find("tofIdx"); it != j.end()) {
    it->get_to(value.tof_idx);
  }
  if (auto it = j.find("energyIndices"); it != j.end()) {
    it->get_to(value.energy_indices);
  }
}

template <typename Shape>
void to_json(ordered_json& j, petsird::SolidVolume<Shape> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.shape)) {
    j.push_back({"shape", value.shape});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.material_id)) {
    j.push_back({"materialId", value.material_id});
  }
}

template <typename Shape>
void from_json(ordered_json const& j, petsird::SolidVolume<Shape>& value) {
  if (auto it = j.find("shape"); it != j.end()) {
    it->get_to(value.shape);
  }
  if (auto it = j.find("materialId"); it != j.end()) {
    it->get_to(value.material_id);
  }
}

void to_json(ordered_json& j, petsird::Coordinate const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.c)) {
    j.push_back({"c", value.c});
  }
}

void from_json(ordered_json const& j, petsird::Coordinate& value) {
  if (auto it = j.find("c"); it != j.end()) {
    it->get_to(value.c);
  }
}

void to_json(ordered_json& j, petsird::BoxShape const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.corners)) {
    j.push_back({"corners", value.corners});
  }
}

void from_json(ordered_json const& j, petsird::BoxShape& value) {
  if (auto it = j.find("corners"); it != j.end()) {
    it->get_to(value.corners);
  }
}

void to_json(ordered_json& j, petsird::AnnulusShape const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.inner_radius)) {
    j.push_back({"innerRadius", value.inner_radius});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.outer_radius)) {
    j.push_back({"outerRadius", value.outer_radius});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.thickness)) {
    j.push_back({"thickness", value.thickness});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.angular_range)) {
    j.push_back({"angularRange", value.angular_range});
  }
}

void from_json(ordered_json const& j, petsird::AnnulusShape& value) {
  if (auto it = j.find("innerRadius"); it != j.end()) {
    it->get_to(value.inner_radius);
  }
  if (auto it = j.find("outerRadius"); it != j.end()) {
    it->get_to(value.outer_radius);
  }
  if (auto it = j.find("thickness"); it != j.end()) {
    it->get_to(value.thickness);
  }
  if (auto it = j.find("angularRange"); it != j.end()) {
    it->get_to(value.angular_range);
  }
}

void to_json(ordered_json& j, petsird::RigidTransformation const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.matrix)) {
    j.push_back({"matrix", value.matrix});
  }
}

void from_json(ordered_json const& j, petsird::RigidTransformation& value) {
  if (auto it = j.find("matrix"); it != j.end()) {
    it->get_to(value.matrix);
  }
}

template <typename T>
void to_json(ordered_json& j, petsird::ReplicatedObject<T> const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.object)) {
    j.push_back({"object", value.object});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.transforms)) {
    j.push_back({"transforms", value.transforms});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ids)) {
    j.push_back({"ids", value.ids});
  }
}

template <typename T>
void from_json(ordered_json const& j, petsird::ReplicatedObject<T>& value) {
  if (auto it = j.find("object"); it != j.end()) {
    it->get_to(value.object);
  }
  if (auto it = j.find("transforms"); it != j.end()) {
    it->get_to(value.transforms);
  }
  if (auto it = j.find("ids"); it != j.end()) {
    it->get_to(value.ids);
  }
}

void to_json(ordered_json& j, petsird::DetectorModule const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.detecting_elements)) {
    j.push_back({"detectingElements", value.detecting_elements});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.detecting_element_ids)) {
    j.push_back({"detectingElementIds", value.detecting_element_ids});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.non_detecting_elements)) {
    j.push_back({"nonDetectingElements", value.non_detecting_elements});
  }
}

void from_json(ordered_json const& j, petsird::DetectorModule& value) {
  if (auto it = j.find("detectingElements"); it != j.end()) {
    it->get_to(value.detecting_elements);
  }
  if (auto it = j.find("detectingElementIds"); it != j.end()) {
    it->get_to(value.detecting_element_ids);
  }
  if (auto it = j.find("nonDetectingElements"); it != j.end()) {
    it->get_to(value.non_detecting_elements);
  }
}

void to_json(ordered_json& j, petsird::ScannerGeometry const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.replicated_modules)) {
    j.push_back({"replicatedModules", value.replicated_modules});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.ids)) {
    j.push_back({"ids", value.ids});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.non_detecting_volumes)) {
    j.push_back({"nonDetectingVolumes", value.non_detecting_volumes});
  }
}

void from_json(ordered_json const& j, petsird::ScannerGeometry& value) {
  if (auto it = j.find("replicatedModules"); it != j.end()) {
    it->get_to(value.replicated_modules);
  }
  if (auto it = j.find("ids"); it != j.end()) {
    it->get_to(value.ids);
  }
  if (auto it = j.find("nonDetectingVolumes"); it != j.end()) {
    it->get_to(value.non_detecting_volumes);
  }
}

void to_json(ordered_json& j, petsird::Subject const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.id)) {
    j.push_back({"id", value.id});
  }
}

void from_json(ordered_json const& j, petsird::Subject& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("id"); it != j.end()) {
    it->get_to(value.id);
  }
}

void to_json(ordered_json& j, petsird::Institution const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.address)) {
    j.push_back({"address", value.address});
  }
}

void from_json(ordered_json const& j, petsird::Institution& value) {
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("address"); it != j.end()) {
    it->get_to(value.address);
  }
}

void to_json(ordered_json& j, petsird::ExamInformation const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.subject)) {
    j.push_back({"subject", value.subject});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.institution)) {
    j.push_back({"institution", value.institution});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.protocol)) {
    j.push_back({"protocol", value.protocol});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.start_of_acquisition)) {
    j.push_back({"startOfAcquisition", value.start_of_acquisition});
  }
}

void from_json(ordered_json const& j, petsird::ExamInformation& value) {
  if (auto it = j.find("subject"); it != j.end()) {
    it->get_to(value.subject);
  }
  if (auto it = j.find("institution"); it != j.end()) {
    it->get_to(value.institution);
  }
  if (auto it = j.find("protocol"); it != j.end()) {
    it->get_to(value.protocol);
  }
  if (auto it = j.find("startOfAcquisition"); it != j.end()) {
    it->get_to(value.start_of_acquisition);
  }
}

void to_json(ordered_json& j, petsird::Direction const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.c)) {
    j.push_back({"c", value.c});
  }
}

void from_json(ordered_json const& j, petsird::Direction& value) {
  if (auto it = j.find("c"); it != j.end()) {
    it->get_to(value.c);
  }
}

void to_json(ordered_json& j, petsird::DirectionMatrix const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.matrix)) {
    j.push_back({"matrix", value.matrix});
  }
}

void from_json(ordered_json const& j, petsird::DirectionMatrix& value) {
  if (auto it = j.find("matrix"); it != j.end()) {
    it->get_to(value.matrix);
  }
}

void to_json(ordered_json& j, petsird::Atom const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.mass_number)) {
    j.push_back({"massNumber", value.mass_number});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.atomic_number)) {
    j.push_back({"atomicNumber", value.atomic_number});
  }
}

void from_json(ordered_json const& j, petsird::Atom& value) {
  if (auto it = j.find("massNumber"); it != j.end()) {
    it->get_to(value.mass_number);
  }
  if (auto it = j.find("atomicNumber"); it != j.end()) {
    it->get_to(value.atomic_number);
  }
}

void to_json(ordered_json& j, petsird::BulkMaterial const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.id)) {
    j.push_back({"id", value.id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.name)) {
    j.push_back({"name", value.name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.density)) {
    j.push_back({"density", value.density});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.atoms)) {
    j.push_back({"atoms", value.atoms});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.mass_fractions)) {
    j.push_back({"massFractions", value.mass_fractions});
  }
}

void from_json(ordered_json const& j, petsird::BulkMaterial& value) {
  if (auto it = j.find("id"); it != j.end()) {
    it->get_to(value.id);
  }
  if (auto it = j.find("name"); it != j.end()) {
    it->get_to(value.name);
  }
  if (auto it = j.find("density"); it != j.end()) {
    it->get_to(value.density);
  }
  if (auto it = j.find("atoms"); it != j.end()) {
    it->get_to(value.atoms);
  }
  if (auto it = j.find("massFractions"); it != j.end()) {
    it->get_to(value.mass_fractions);
  }
}

namespace {
std::unordered_map<std::string, petsird::CoincidencePolicy> const __CoincidencePolicy_values = {
  {"rejectMultiples", petsird::CoincidencePolicy::kRejectMultiples},
  {"storeMultiplesAsPairs", petsird::CoincidencePolicy::kStoreMultiplesAsPairs},
  {"other", petsird::CoincidencePolicy::kOther},
};
} //namespace

void to_json(ordered_json& j, petsird::CoincidencePolicy const& value) {
  switch (value) {
    case petsird::CoincidencePolicy::kRejectMultiples:
      j = "rejectMultiples";
      break;
    case petsird::CoincidencePolicy::kStoreMultiplesAsPairs:
      j = "storeMultiplesAsPairs";
      break;
    case petsird::CoincidencePolicy::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<petsird::CoincidencePolicy>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, petsird::CoincidencePolicy& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __CoincidencePolicy_values.find(symbol); res != __CoincidencePolicy_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum petsird::CoincidencePolicy");
  }
  using underlying_type = typename std::underlying_type<petsird::CoincidencePolicy>::type;
  value = static_cast<petsird::CoincidencePolicy>(j.get<underlying_type>());
}

void to_json(ordered_json& j, petsird::ScannerInformation const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.model_name)) {
    j.push_back({"modelName", value.model_name});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.scanner_geometry)) {
    j.push_back({"scannerGeometry", value.scanner_geometry});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.bulk_materials)) {
    j.push_back({"bulkMaterials", value.bulk_materials});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.gantry_alignment)) {
    j.push_back({"gantryAlignment", value.gantry_alignment});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.tof_bin_edges)) {
    j.push_back({"tofBinEdges", value.tof_bin_edges});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.tof_resolution)) {
    j.push_back({"tofResolution", value.tof_resolution});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.energy_bin_edges)) {
    j.push_back({"energyBinEdges", value.energy_bin_edges});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.energy_resolution_at_511)) {
    j.push_back({"energyResolutionAt511", value.energy_resolution_at_511});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.event_time_block_duration)) {
    j.push_back({"eventTimeBlockDuration", value.event_time_block_duration});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.coincidence_policy)) {
    j.push_back({"coincidencePolicy", value.coincidence_policy});
  }
}

void from_json(ordered_json const& j, petsird::ScannerInformation& value) {
  if (auto it = j.find("modelName"); it != j.end()) {
    it->get_to(value.model_name);
  }
  if (auto it = j.find("scannerGeometry"); it != j.end()) {
    it->get_to(value.scanner_geometry);
  }
  if (auto it = j.find("bulkMaterials"); it != j.end()) {
    it->get_to(value.bulk_materials);
  }
  if (auto it = j.find("gantryAlignment"); it != j.end()) {
    it->get_to(value.gantry_alignment);
  }
  if (auto it = j.find("tofBinEdges"); it != j.end()) {
    it->get_to(value.tof_bin_edges);
  }
  if (auto it = j.find("tofResolution"); it != j.end()) {
    it->get_to(value.tof_resolution);
  }
  if (auto it = j.find("energyBinEdges"); it != j.end()) {
    it->get_to(value.energy_bin_edges);
  }
  if (auto it = j.find("energyResolutionAt511"); it != j.end()) {
    it->get_to(value.energy_resolution_at_511);
  }
  if (auto it = j.find("eventTimeBlockDuration"); it != j.end()) {
    it->get_to(value.event_time_block_duration);
  }
  if (auto it = j.find("coincidencePolicy"); it != j.end()) {
    it->get_to(value.coincidence_policy);
  }
}

void to_json(ordered_json& j, petsird::Header const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.scanner)) {
    j.push_back({"scanner", value.scanner});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.exam)) {
    j.push_back({"exam", value.exam});
  }
}

void from_json(ordered_json const& j, petsird::Header& value) {
  if (auto it = j.find("scanner"); it != j.end()) {
    it->get_to(value.scanner);
  }
  if (auto it = j.find("exam"); it != j.end()) {
    it->get_to(value.exam);
  }
}

void to_json(ordered_json& j, petsird::TripleEvent const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.detector_ids)) {
    j.push_back({"detectorIds", value.detector_ids});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.tof_indices)) {
    j.push_back({"tofIndices", value.tof_indices});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.energy_indices)) {
    j.push_back({"energyIndices", value.energy_indices});
  }
}

void from_json(ordered_json const& j, petsird::TripleEvent& value) {
  if (auto it = j.find("detectorIds"); it != j.end()) {
    it->get_to(value.detector_ids);
  }
  if (auto it = j.find("tofIndices"); it != j.end()) {
    it->get_to(value.tof_indices);
  }
  if (auto it = j.find("energyIndices"); it != j.end()) {
    it->get_to(value.energy_indices);
  }
}

void to_json(ordered_json& j, petsird::EventTimeBlock const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.start)) {
    j.push_back({"start", value.start});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.prompt_events)) {
    j.push_back({"promptEvents", value.prompt_events});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.delayed_events)) {
    j.push_back({"delayedEvents", value.delayed_events});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.triple_events)) {
    j.push_back({"tripleEvents", value.triple_events});
  }
}

void from_json(ordered_json const& j, petsird::EventTimeBlock& value) {
  if (auto it = j.find("start"); it != j.end()) {
    it->get_to(value.start);
  }
  if (auto it = j.find("promptEvents"); it != j.end()) {
    it->get_to(value.prompt_events);
  }
  if (auto it = j.find("delayedEvents"); it != j.end()) {
    it->get_to(value.delayed_events);
  }
  if (auto it = j.find("tripleEvents"); it != j.end()) {
    it->get_to(value.triple_events);
  }
}

void to_json(ordered_json& j, petsird::ExternalSignalTimeBlock const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.start)) {
    j.push_back({"start", value.start});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.signal_id)) {
    j.push_back({"signalID", value.signal_id});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.signal_values)) {
    j.push_back({"signalValues", value.signal_values});
  }
}

void from_json(ordered_json const& j, petsird::ExternalSignalTimeBlock& value) {
  if (auto it = j.find("start"); it != j.end()) {
    it->get_to(value.start);
  }
  if (auto it = j.find("signalID"); it != j.end()) {
    it->get_to(value.signal_id);
  }
  if (auto it = j.find("signalValues"); it != j.end()) {
    it->get_to(value.signal_values);
  }
}

void to_json(ordered_json& j, petsird::BedMovementTimeBlock const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.start)) {
    j.push_back({"start", value.start});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.transform)) {
    j.push_back({"transform", value.transform});
  }
}

void from_json(ordered_json const& j, petsird::BedMovementTimeBlock& value) {
  if (auto it = j.find("start"); it != j.end()) {
    it->get_to(value.start);
  }
  if (auto it = j.find("transform"); it != j.end()) {
    it->get_to(value.transform);
  }
}

void to_json(ordered_json& j, petsird::GantryMovementTimeBlock const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.start)) {
    j.push_back({"start", value.start});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.transform)) {
    j.push_back({"transform", value.transform});
  }
}

void from_json(ordered_json const& j, petsird::GantryMovementTimeBlock& value) {
  if (auto it = j.find("start"); it != j.end()) {
    it->get_to(value.start);
  }
  if (auto it = j.find("transform"); it != j.end()) {
    it->get_to(value.transform);
  }
}

namespace {
std::unordered_map<std::string, petsird::ExternalSignalTypeEnum> const __ExternalSignalTypeEnum_values = {
  {"ecgTrace", petsird::ExternalSignalTypeEnum::kEcgTrace},
  {"ecgTrigger", petsird::ExternalSignalTypeEnum::kEcgTrigger},
  {"respTrace", petsird::ExternalSignalTypeEnum::kRespTrace},
  {"respTrigger", petsird::ExternalSignalTypeEnum::kRespTrigger},
  {"otherMotionSignal", petsird::ExternalSignalTypeEnum::kOtherMotionSignal},
  {"otherMotionTrigger", petsird::ExternalSignalTypeEnum::kOtherMotionTrigger},
  {"externalSync", petsird::ExternalSignalTypeEnum::kExternalSync},
  {"other", petsird::ExternalSignalTypeEnum::kOther},
};
} //namespace

void to_json(ordered_json& j, petsird::ExternalSignalTypeEnum const& value) {
  switch (value) {
    case petsird::ExternalSignalTypeEnum::kEcgTrace:
      j = "ecgTrace";
      break;
    case petsird::ExternalSignalTypeEnum::kEcgTrigger:
      j = "ecgTrigger";
      break;
    case petsird::ExternalSignalTypeEnum::kRespTrace:
      j = "respTrace";
      break;
    case petsird::ExternalSignalTypeEnum::kRespTrigger:
      j = "respTrigger";
      break;
    case petsird::ExternalSignalTypeEnum::kOtherMotionSignal:
      j = "otherMotionSignal";
      break;
    case petsird::ExternalSignalTypeEnum::kOtherMotionTrigger:
      j = "otherMotionTrigger";
      break;
    case petsird::ExternalSignalTypeEnum::kExternalSync:
      j = "externalSync";
      break;
    case petsird::ExternalSignalTypeEnum::kOther:
      j = "other";
      break;
    default:
      using underlying_type = typename std::underlying_type<petsird::ExternalSignalTypeEnum>::type;
      j = static_cast<underlying_type>(value);
      break;
  }
}

void from_json(ordered_json const& j, petsird::ExternalSignalTypeEnum& value) {
  if (j.is_string()) {
    auto symbol = j.get<std::string>();
    if (auto res = __ExternalSignalTypeEnum_values.find(symbol); res != __ExternalSignalTypeEnum_values.end()) {
      value = res->second;
      return;
    }
    throw std::runtime_error("Invalid enum value '" + symbol + "' for enum petsird::ExternalSignalTypeEnum");
  }
  using underlying_type = typename std::underlying_type<petsird::ExternalSignalTypeEnum>::type;
  value = static_cast<petsird::ExternalSignalTypeEnum>(j.get<underlying_type>());
}

void to_json(ordered_json& j, petsird::ExternalSignalType const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.type)) {
    j.push_back({"type", value.type});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.description)) {
    j.push_back({"description", value.description});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.id)) {
    j.push_back({"id", value.id});
  }
}

void from_json(ordered_json const& j, petsird::ExternalSignalType& value) {
  if (auto it = j.find("type"); it != j.end()) {
    it->get_to(value.type);
  }
  if (auto it = j.find("description"); it != j.end()) {
    it->get_to(value.description);
  }
  if (auto it = j.find("id"); it != j.end()) {
    it->get_to(value.id);
  }
}

void to_json(ordered_json& j, petsird::TimeInterval const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.start)) {
    j.push_back({"start", value.start});
  }
  if (yardl::ndjson::ShouldSerializeFieldValue(value.stop)) {
    j.push_back({"stop", value.stop});
  }
}

void from_json(ordered_json const& j, petsird::TimeInterval& value) {
  if (auto it = j.find("start"); it != j.end()) {
    it->get_to(value.start);
  }
  if (auto it = j.find("stop"); it != j.end()) {
    it->get_to(value.stop);
  }
}

void to_json(ordered_json& j, petsird::TimeFrameInformation const& value) {
  j = ordered_json::object();
  if (yardl::ndjson::ShouldSerializeFieldValue(value.time_frames)) {
    j.push_back({"timeFrames", value.time_frames});
  }
}

void from_json(ordered_json const& j, petsird::TimeFrameInformation& value) {
  if (auto it = j.find("timeFrames"); it != j.end()) {
    it->get_to(value.time_frames);
  }
}

} // namespace petsird

namespace petsird::ndjson {
void PETSIRDWriter::WriteHeaderImpl(petsird::Header const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "header", json_value);}

void PETSIRDWriter::WriteTimeBlocksImpl(petsird::TimeBlock const& value) {
  ordered_json json_value = value;
  yardl::ndjson::WriteProtocolValue(stream_, "timeBlocks", json_value);}

void PETSIRDWriter::Flush() {
  stream_.flush();
}

void PETSIRDWriter::CloseImpl() {
  stream_.flush();
}

void PETSIRDReader::ReadHeaderImpl(petsird::Header& value) {
  yardl::ndjson::ReadProtocolValue(stream_, line_, "header", true, unused_step_, value);
}

bool PETSIRDReader::ReadTimeBlocksImpl(petsird::TimeBlock& value) {
  return yardl::ndjson::ReadProtocolValue(stream_, line_, "timeBlocks", false, unused_step_, value);
}

void PETSIRDReader::CloseImpl() {
  VerifyFinished();
}

} // namespace petsird::ndjson

