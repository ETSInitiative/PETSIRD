// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#include <cstddef>

#include "../yardl/detail/binary/coded_stream.h"
#include "../yardl/detail/binary/serializers.h"

namespace yardl::binary {
#ifndef _MSC_VER
// Values of offsetof() are only used if types are standard-layout.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Winvalid-offsetof"
#endif

template <>
struct IsTriviallySerializable<petsird::CoincidenceEvent> {
  using __T__ = petsird::CoincidenceEvent;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::detector_ids)>::value &&
    IsTriviallySerializable<decltype(__T__::tof_idx)>::value &&
    IsTriviallySerializable<decltype(__T__::energy_indices)>::value &&
    (sizeof(__T__) == (sizeof(__T__::detector_ids) + sizeof(__T__::tof_idx) + sizeof(__T__::energy_indices))) &&
    offsetof(__T__, detector_ids) < offsetof(__T__, tof_idx) && offsetof(__T__, tof_idx) < offsetof(__T__, energy_indices);
};

template <typename Shape>
struct IsTriviallySerializable<petsird::SolidVolume<Shape>> {
  using __T__ = petsird::SolidVolume<Shape>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::shape)>::value &&
    IsTriviallySerializable<decltype(__T__::material_id)>::value &&
    (sizeof(__T__) == (sizeof(__T__::shape) + sizeof(__T__::material_id))) &&
    offsetof(__T__, shape) < offsetof(__T__, material_id);
};

template <>
struct IsTriviallySerializable<petsird::Coordinate> {
  using __T__ = petsird::Coordinate;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::c)>::value &&
    (sizeof(__T__) == (sizeof(__T__::c)));
};

template <>
struct IsTriviallySerializable<petsird::BoxShape> {
  using __T__ = petsird::BoxShape;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::corners)>::value &&
    (sizeof(__T__) == (sizeof(__T__::corners)));
};

template <>
struct IsTriviallySerializable<petsird::AnnulusShape> {
  using __T__ = petsird::AnnulusShape;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::inner_radius)>::value &&
    IsTriviallySerializable<decltype(__T__::outer_radius)>::value &&
    IsTriviallySerializable<decltype(__T__::thickness)>::value &&
    IsTriviallySerializable<decltype(__T__::angular_range)>::value &&
    (sizeof(__T__) == (sizeof(__T__::inner_radius) + sizeof(__T__::outer_radius) + sizeof(__T__::thickness) + sizeof(__T__::angular_range))) &&
    offsetof(__T__, inner_radius) < offsetof(__T__, outer_radius) && offsetof(__T__, outer_radius) < offsetof(__T__, thickness) && offsetof(__T__, thickness) < offsetof(__T__, angular_range);
};

template <>
struct IsTriviallySerializable<petsird::RigidTransformation> {
  using __T__ = petsird::RigidTransformation;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::matrix)>::value &&
    (sizeof(__T__) == (sizeof(__T__::matrix)));
};

template <typename T>
struct IsTriviallySerializable<petsird::ReplicatedObject<T>> {
  using __T__ = petsird::ReplicatedObject<T>;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::object)>::value &&
    IsTriviallySerializable<decltype(__T__::transforms)>::value &&
    IsTriviallySerializable<decltype(__T__::ids)>::value &&
    (sizeof(__T__) == (sizeof(__T__::object) + sizeof(__T__::transforms) + sizeof(__T__::ids))) &&
    offsetof(__T__, object) < offsetof(__T__, transforms) && offsetof(__T__, transforms) < offsetof(__T__, ids);
};

template <>
struct IsTriviallySerializable<petsird::DetectorModule> {
  using __T__ = petsird::DetectorModule;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::detecting_elements)>::value &&
    IsTriviallySerializable<decltype(__T__::detecting_element_ids)>::value &&
    IsTriviallySerializable<decltype(__T__::non_detecting_elements)>::value &&
    (sizeof(__T__) == (sizeof(__T__::detecting_elements) + sizeof(__T__::detecting_element_ids) + sizeof(__T__::non_detecting_elements))) &&
    offsetof(__T__, detecting_elements) < offsetof(__T__, detecting_element_ids) && offsetof(__T__, detecting_element_ids) < offsetof(__T__, non_detecting_elements);
};

template <>
struct IsTriviallySerializable<petsird::ScannerGeometry> {
  using __T__ = petsird::ScannerGeometry;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::replicated_modules)>::value &&
    IsTriviallySerializable<decltype(__T__::ids)>::value &&
    IsTriviallySerializable<decltype(__T__::non_detecting_volumes)>::value &&
    (sizeof(__T__) == (sizeof(__T__::replicated_modules) + sizeof(__T__::ids) + sizeof(__T__::non_detecting_volumes))) &&
    offsetof(__T__, replicated_modules) < offsetof(__T__, ids) && offsetof(__T__, ids) < offsetof(__T__, non_detecting_volumes);
};

template <>
struct IsTriviallySerializable<petsird::Subject> {
  using __T__ = petsird::Subject;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::id)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::id))) &&
    offsetof(__T__, name) < offsetof(__T__, id);
};

template <>
struct IsTriviallySerializable<petsird::Institution> {
  using __T__ = petsird::Institution;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::address)>::value &&
    (sizeof(__T__) == (sizeof(__T__::name) + sizeof(__T__::address))) &&
    offsetof(__T__, name) < offsetof(__T__, address);
};

template <>
struct IsTriviallySerializable<petsird::ExamInformation> {
  using __T__ = petsird::ExamInformation;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::subject)>::value &&
    IsTriviallySerializable<decltype(__T__::institution)>::value &&
    IsTriviallySerializable<decltype(__T__::protocol)>::value &&
    IsTriviallySerializable<decltype(__T__::start_of_acquisition)>::value &&
    (sizeof(__T__) == (sizeof(__T__::subject) + sizeof(__T__::institution) + sizeof(__T__::protocol) + sizeof(__T__::start_of_acquisition))) &&
    offsetof(__T__, subject) < offsetof(__T__, institution) && offsetof(__T__, institution) < offsetof(__T__, protocol) && offsetof(__T__, protocol) < offsetof(__T__, start_of_acquisition);
};

template <>
struct IsTriviallySerializable<petsird::Direction> {
  using __T__ = petsird::Direction;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::c)>::value &&
    (sizeof(__T__) == (sizeof(__T__::c)));
};

template <>
struct IsTriviallySerializable<petsird::DirectionMatrix> {
  using __T__ = petsird::DirectionMatrix;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::matrix)>::value &&
    (sizeof(__T__) == (sizeof(__T__::matrix)));
};

template <>
struct IsTriviallySerializable<petsird::Atom> {
  using __T__ = petsird::Atom;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::mass_number)>::value &&
    IsTriviallySerializable<decltype(__T__::atomic_number)>::value &&
    (sizeof(__T__) == (sizeof(__T__::mass_number) + sizeof(__T__::atomic_number))) &&
    offsetof(__T__, mass_number) < offsetof(__T__, atomic_number);
};

template <>
struct IsTriviallySerializable<petsird::BulkMaterial> {
  using __T__ = petsird::BulkMaterial;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::id)>::value &&
    IsTriviallySerializable<decltype(__T__::name)>::value &&
    IsTriviallySerializable<decltype(__T__::density)>::value &&
    IsTriviallySerializable<decltype(__T__::atoms)>::value &&
    IsTriviallySerializable<decltype(__T__::mass_fractions)>::value &&
    (sizeof(__T__) == (sizeof(__T__::id) + sizeof(__T__::name) + sizeof(__T__::density) + sizeof(__T__::atoms) + sizeof(__T__::mass_fractions))) &&
    offsetof(__T__, id) < offsetof(__T__, name) && offsetof(__T__, name) < offsetof(__T__, density) && offsetof(__T__, density) < offsetof(__T__, atoms) && offsetof(__T__, atoms) < offsetof(__T__, mass_fractions);
};

template <>
struct IsTriviallySerializable<petsird::ScannerInformation> {
  using __T__ = petsird::ScannerInformation;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::model_name)>::value &&
    IsTriviallySerializable<decltype(__T__::scanner_geometry)>::value &&
    IsTriviallySerializable<decltype(__T__::bulk_materials)>::value &&
    IsTriviallySerializable<decltype(__T__::gantry_alignment)>::value &&
    IsTriviallySerializable<decltype(__T__::tof_bin_edges)>::value &&
    IsTriviallySerializable<decltype(__T__::tof_resolution)>::value &&
    IsTriviallySerializable<decltype(__T__::energy_bin_edges)>::value &&
    IsTriviallySerializable<decltype(__T__::energy_resolution_at_511)>::value &&
    IsTriviallySerializable<decltype(__T__::event_time_block_duration)>::value &&
    IsTriviallySerializable<decltype(__T__::coincidence_policy)>::value &&
    (sizeof(__T__) == (sizeof(__T__::model_name) + sizeof(__T__::scanner_geometry) + sizeof(__T__::bulk_materials) + sizeof(__T__::gantry_alignment) + sizeof(__T__::tof_bin_edges) + sizeof(__T__::tof_resolution) + sizeof(__T__::energy_bin_edges) + sizeof(__T__::energy_resolution_at_511) + sizeof(__T__::event_time_block_duration) + sizeof(__T__::coincidence_policy))) &&
    offsetof(__T__, model_name) < offsetof(__T__, scanner_geometry) && offsetof(__T__, scanner_geometry) < offsetof(__T__, bulk_materials) && offsetof(__T__, bulk_materials) < offsetof(__T__, gantry_alignment) && offsetof(__T__, gantry_alignment) < offsetof(__T__, tof_bin_edges) && offsetof(__T__, tof_bin_edges) < offsetof(__T__, tof_resolution) && offsetof(__T__, tof_resolution) < offsetof(__T__, energy_bin_edges) && offsetof(__T__, energy_bin_edges) < offsetof(__T__, energy_resolution_at_511) && offsetof(__T__, energy_resolution_at_511) < offsetof(__T__, event_time_block_duration) && offsetof(__T__, event_time_block_duration) < offsetof(__T__, coincidence_policy);
};

template <>
struct IsTriviallySerializable<petsird::Header> {
  using __T__ = petsird::Header;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::scanner)>::value &&
    IsTriviallySerializable<decltype(__T__::exam)>::value &&
    (sizeof(__T__) == (sizeof(__T__::scanner) + sizeof(__T__::exam))) &&
    offsetof(__T__, scanner) < offsetof(__T__, exam);
};

template <>
struct IsTriviallySerializable<petsird::TripleEvent> {
  using __T__ = petsird::TripleEvent;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::detector_ids)>::value &&
    IsTriviallySerializable<decltype(__T__::tof_indices)>::value &&
    IsTriviallySerializable<decltype(__T__::energy_indices)>::value &&
    (sizeof(__T__) == (sizeof(__T__::detector_ids) + sizeof(__T__::tof_indices) + sizeof(__T__::energy_indices))) &&
    offsetof(__T__, detector_ids) < offsetof(__T__, tof_indices) && offsetof(__T__, tof_indices) < offsetof(__T__, energy_indices);
};

template <>
struct IsTriviallySerializable<petsird::EventTimeBlock> {
  using __T__ = petsird::EventTimeBlock;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::start)>::value &&
    IsTriviallySerializable<decltype(__T__::prompt_events)>::value &&
    IsTriviallySerializable<decltype(__T__::delayed_events)>::value &&
    IsTriviallySerializable<decltype(__T__::triple_events)>::value &&
    (sizeof(__T__) == (sizeof(__T__::start) + sizeof(__T__::prompt_events) + sizeof(__T__::delayed_events) + sizeof(__T__::triple_events))) &&
    offsetof(__T__, start) < offsetof(__T__, prompt_events) && offsetof(__T__, prompt_events) < offsetof(__T__, delayed_events) && offsetof(__T__, delayed_events) < offsetof(__T__, triple_events);
};

template <>
struct IsTriviallySerializable<petsird::ExternalSignalTimeBlock> {
  using __T__ = petsird::ExternalSignalTimeBlock;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::start)>::value &&
    IsTriviallySerializable<decltype(__T__::signal_id)>::value &&
    IsTriviallySerializable<decltype(__T__::signal_values)>::value &&
    (sizeof(__T__) == (sizeof(__T__::start) + sizeof(__T__::signal_id) + sizeof(__T__::signal_values))) &&
    offsetof(__T__, start) < offsetof(__T__, signal_id) && offsetof(__T__, signal_id) < offsetof(__T__, signal_values);
};

template <>
struct IsTriviallySerializable<petsird::BedMovementTimeBlock> {
  using __T__ = petsird::BedMovementTimeBlock;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::start)>::value &&
    IsTriviallySerializable<decltype(__T__::transform)>::value &&
    (sizeof(__T__) == (sizeof(__T__::start) + sizeof(__T__::transform))) &&
    offsetof(__T__, start) < offsetof(__T__, transform);
};

template <>
struct IsTriviallySerializable<petsird::GantryMovementTimeBlock> {
  using __T__ = petsird::GantryMovementTimeBlock;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::start)>::value &&
    IsTriviallySerializable<decltype(__T__::transform)>::value &&
    (sizeof(__T__) == (sizeof(__T__::start) + sizeof(__T__::transform))) &&
    offsetof(__T__, start) < offsetof(__T__, transform);
};

template <>
struct IsTriviallySerializable<petsird::ExternalSignalType> {
  using __T__ = petsird::ExternalSignalType;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::type)>::value &&
    IsTriviallySerializable<decltype(__T__::description)>::value &&
    IsTriviallySerializable<decltype(__T__::id)>::value &&
    (sizeof(__T__) == (sizeof(__T__::type) + sizeof(__T__::description) + sizeof(__T__::id))) &&
    offsetof(__T__, type) < offsetof(__T__, description) && offsetof(__T__, description) < offsetof(__T__, id);
};

template <>
struct IsTriviallySerializable<petsird::TimeInterval> {
  using __T__ = petsird::TimeInterval;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::start)>::value &&
    IsTriviallySerializable<decltype(__T__::stop)>::value &&
    (sizeof(__T__) == (sizeof(__T__::start) + sizeof(__T__::stop))) &&
    offsetof(__T__, start) < offsetof(__T__, stop);
};

template <>
struct IsTriviallySerializable<petsird::TimeFrameInformation> {
  using __T__ = petsird::TimeFrameInformation;
  static constexpr bool value = 
    std::is_standard_layout_v<__T__> &&
    IsTriviallySerializable<decltype(__T__::time_frames)>::value &&
    (sizeof(__T__) == (sizeof(__T__::time_frames)));
};

#ifndef _MSC_VER
#pragma GCC diagnostic pop // #pragma GCC diagnostic ignored "-Winvalid-offsetof" 
#endif
} //namespace yardl::binary 

namespace {
template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Writer<T0> WriteT0, typename T1, yardl::binary::Writer<T1> WriteT1, typename T2, yardl::binary::Writer<T2> WriteT2, typename T3, yardl::binary::Writer<T3> WriteT3>
void WriteUnion(yardl::binary::CodedOutputStream& stream, std::variant<T0, T1, T2, T3> const& value) {
  yardl::binary::WriteInteger(stream, value.index());
  switch (value.index()) {
  case 0: {
    T0 const& v = std::get<0>(value);
    WriteT0(stream, v);
    break;
  }
  case 1: {
    T1 const& v = std::get<1>(value);
    WriteT1(stream, v);
    break;
  }
  case 2: {
    T2 const& v = std::get<2>(value);
    WriteT2(stream, v);
    break;
  }
  case 3: {
    T3 const& v = std::get<3>(value);
    WriteT3(stream, v);
    break;
  }
  default: throw std::runtime_error("Invalid union index.");
  }
}

template<typename T0, yardl::binary::Reader<T0> ReadT0, typename T1, yardl::binary::Reader<T1> ReadT1, typename T2, yardl::binary::Reader<T2> ReadT2, typename T3, yardl::binary::Reader<T3> ReadT3>
void ReadUnion(yardl::binary::CodedInputStream& stream, std::variant<T0, T1, T2, T3>& value) {
  size_t index;
  yardl::binary::ReadInteger(stream, index);
  switch (index) {
    case 0: {
      T0 v;
      ReadT0(stream, v);
      value = std::move(v);
      break;
    }
    case 1: {
      T1 v;
      ReadT1(stream, v);
      value = std::move(v);
      break;
    }
    case 2: {
      T2 v;
      ReadT2(stream, v);
      value = std::move(v);
      break;
    }
    case 3: {
      T3 v;
      ReadT3(stream, v);
      value = std::move(v);
      break;
    }
    default: throw std::runtime_error("Invalid union index.");
  }
}
} // namespace

namespace petsird::binary {
namespace {
[[maybe_unused]] void WriteCoincidenceEvent(yardl::binary::CodedOutputStream& stream, petsird::CoincidenceEvent const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::CoincidenceEvent>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<uint32_t, yardl::binary::WriteInteger, 2>(stream, value.detector_ids);
  yardl::binary::WriteInteger(stream, value.tof_idx);
  yardl::binary::WriteArray<uint32_t, yardl::binary::WriteInteger, 2>(stream, value.energy_indices);
}

[[maybe_unused]] void ReadCoincidenceEvent(yardl::binary::CodedInputStream& stream, petsird::CoincidenceEvent& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::CoincidenceEvent>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<uint32_t, yardl::binary::ReadInteger, 2>(stream, value.detector_ids);
  yardl::binary::ReadInteger(stream, value.tof_idx);
  yardl::binary::ReadArray<uint32_t, yardl::binary::ReadInteger, 2>(stream, value.energy_indices);
}

template<typename Shape, yardl::binary::Writer<Shape> WriteShape>
[[maybe_unused]] void WriteSolidVolume(yardl::binary::CodedOutputStream& stream, petsird::SolidVolume<Shape> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::SolidVolume<Shape>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteShape(stream, value.shape);
  yardl::binary::WriteInteger(stream, value.material_id);
}

template<typename Shape, yardl::binary::Reader<Shape> ReadShape>
[[maybe_unused]] void ReadSolidVolume(yardl::binary::CodedInputStream& stream, petsird::SolidVolume<Shape>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::SolidVolume<Shape>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadShape(stream, value.shape);
  yardl::binary::ReadInteger(stream, value.material_id);
}

[[maybe_unused]] void WriteCoordinate(yardl::binary::CodedOutputStream& stream, petsird::Coordinate const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Coordinate>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.c);
}

[[maybe_unused]] void ReadCoordinate(yardl::binary::CodedInputStream& stream, petsird::Coordinate& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Coordinate>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.c);
}

[[maybe_unused]] void WriteBoxShape(yardl::binary::CodedOutputStream& stream, petsird::BoxShape const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BoxShape>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<petsird::Coordinate, petsird::binary::WriteCoordinate, 8>(stream, value.corners);
}

[[maybe_unused]] void ReadBoxShape(yardl::binary::CodedInputStream& stream, petsird::BoxShape& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BoxShape>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<petsird::Coordinate, petsird::binary::ReadCoordinate, 8>(stream, value.corners);
}

[[maybe_unused]] void WriteBoxSolidVolume(yardl::binary::CodedOutputStream& stream, petsird::BoxSolidVolume const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BoxSolidVolume>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteSolidVolume<petsird::BoxShape, petsird::binary::WriteBoxShape>(stream, value);
}

[[maybe_unused]] void ReadBoxSolidVolume(yardl::binary::CodedInputStream& stream, petsird::BoxSolidVolume& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BoxSolidVolume>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadSolidVolume<petsird::BoxShape, petsird::binary::ReadBoxShape>(stream, value);
}

[[maybe_unused]] void WriteAnnulusShape(yardl::binary::CodedOutputStream& stream, petsird::AnnulusShape const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::AnnulusShape>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFloatingPoint(stream, value.inner_radius);
  yardl::binary::WriteFloatingPoint(stream, value.outer_radius);
  yardl::binary::WriteFloatingPoint(stream, value.thickness);
  yardl::binary::WriteArray<float, yardl::binary::WriteFloatingPoint, 2>(stream, value.angular_range);
}

[[maybe_unused]] void ReadAnnulusShape(yardl::binary::CodedInputStream& stream, petsird::AnnulusShape& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::AnnulusShape>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFloatingPoint(stream, value.inner_radius);
  yardl::binary::ReadFloatingPoint(stream, value.outer_radius);
  yardl::binary::ReadFloatingPoint(stream, value.thickness);
  yardl::binary::ReadArray<float, yardl::binary::ReadFloatingPoint, 2>(stream, value.angular_range);
}

[[maybe_unused]] void WriteGeometricShape(yardl::binary::CodedOutputStream& stream, petsird::GeometricShape const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::GeometricShape>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<petsird::BoxShape, petsird::binary::WriteBoxShape, petsird::AnnulusShape, petsird::binary::WriteAnnulusShape>(stream, value);
}

[[maybe_unused]] void ReadGeometricShape(yardl::binary::CodedInputStream& stream, petsird::GeometricShape& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::GeometricShape>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<petsird::BoxShape, petsird::binary::ReadBoxShape, petsird::AnnulusShape, petsird::binary::ReadAnnulusShape>(stream, value);
}

[[maybe_unused]] void WriteGenericSolidVolume(yardl::binary::CodedOutputStream& stream, petsird::GenericSolidVolume const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::GenericSolidVolume>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteSolidVolume<petsird::GeometricShape, petsird::binary::WriteGeometricShape>(stream, value);
}

[[maybe_unused]] void ReadGenericSolidVolume(yardl::binary::CodedInputStream& stream, petsird::GenericSolidVolume& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::GenericSolidVolume>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadSolidVolume<petsird::GeometricShape, petsird::binary::ReadGeometricShape>(stream, value);
}

[[maybe_unused]] void WriteRigidTransformation(yardl::binary::CodedOutputStream& stream, petsird::RigidTransformation const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::RigidTransformation>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3, 4>(stream, value.matrix);
}

[[maybe_unused]] void ReadRigidTransformation(yardl::binary::CodedInputStream& stream, petsird::RigidTransformation& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::RigidTransformation>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3, 4>(stream, value.matrix);
}

template<typename T, yardl::binary::Writer<T> WriteT>
[[maybe_unused]] void WriteReplicatedObject(yardl::binary::CodedOutputStream& stream, petsird::ReplicatedObject<T> const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedObject<T>>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteT(stream, value.object);
  yardl::binary::WriteVector<petsird::RigidTransformation, petsird::binary::WriteRigidTransformation>(stream, value.transforms);
  yardl::binary::WriteVector<uint32_t, yardl::binary::WriteInteger>(stream, value.ids);
}

template<typename T, yardl::binary::Reader<T> ReadT>
[[maybe_unused]] void ReadReplicatedObject(yardl::binary::CodedInputStream& stream, petsird::ReplicatedObject<T>& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedObject<T>>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadT(stream, value.object);
  yardl::binary::ReadVector<petsird::RigidTransformation, petsird::binary::ReadRigidTransformation>(stream, value.transforms);
  yardl::binary::ReadVector<uint32_t, yardl::binary::ReadInteger>(stream, value.ids);
}

[[maybe_unused]] void WriteReplicatedBoxSolidVolume(yardl::binary::CodedOutputStream& stream, petsird::ReplicatedBoxSolidVolume const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedBoxSolidVolume>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteReplicatedObject<petsird::BoxSolidVolume, petsird::binary::WriteBoxSolidVolume>(stream, value);
}

[[maybe_unused]] void ReadReplicatedBoxSolidVolume(yardl::binary::CodedInputStream& stream, petsird::ReplicatedBoxSolidVolume& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedBoxSolidVolume>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadReplicatedObject<petsird::BoxSolidVolume, petsird::binary::ReadBoxSolidVolume>(stream, value);
}

[[maybe_unused]] void WriteReplicatedGenericSolidVolume(yardl::binary::CodedOutputStream& stream, petsird::ReplicatedGenericSolidVolume const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedGenericSolidVolume>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteReplicatedObject<petsird::GenericSolidVolume, petsird::binary::WriteGenericSolidVolume>(stream, value);
}

[[maybe_unused]] void ReadReplicatedGenericSolidVolume(yardl::binary::CodedInputStream& stream, petsird::ReplicatedGenericSolidVolume& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedGenericSolidVolume>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadReplicatedObject<petsird::GenericSolidVolume, petsird::binary::ReadGenericSolidVolume>(stream, value);
}

[[maybe_unused]] void WriteDetectorModule(yardl::binary::CodedOutputStream& stream, petsird::DetectorModule const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::DetectorModule>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<petsird::ReplicatedBoxSolidVolume, petsird::binary::WriteReplicatedBoxSolidVolume>(stream, value.detecting_elements);
  yardl::binary::WriteVector<uint32_t, yardl::binary::WriteInteger>(stream, value.detecting_element_ids);
  yardl::binary::WriteVector<petsird::ReplicatedGenericSolidVolume, petsird::binary::WriteReplicatedGenericSolidVolume>(stream, value.non_detecting_elements);
}

[[maybe_unused]] void ReadDetectorModule(yardl::binary::CodedInputStream& stream, petsird::DetectorModule& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::DetectorModule>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<petsird::ReplicatedBoxSolidVolume, petsird::binary::ReadReplicatedBoxSolidVolume>(stream, value.detecting_elements);
  yardl::binary::ReadVector<uint32_t, yardl::binary::ReadInteger>(stream, value.detecting_element_ids);
  yardl::binary::ReadVector<petsird::ReplicatedGenericSolidVolume, petsird::binary::ReadReplicatedGenericSolidVolume>(stream, value.non_detecting_elements);
}

[[maybe_unused]] void WriteReplicatedDetectorModule(yardl::binary::CodedOutputStream& stream, petsird::ReplicatedDetectorModule const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedDetectorModule>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteReplicatedObject<petsird::DetectorModule, petsird::binary::WriteDetectorModule>(stream, value);
}

[[maybe_unused]] void ReadReplicatedDetectorModule(yardl::binary::CodedInputStream& stream, petsird::ReplicatedDetectorModule& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ReplicatedDetectorModule>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadReplicatedObject<petsird::DetectorModule, petsird::binary::ReadDetectorModule>(stream, value);
}

[[maybe_unused]] void WriteScannerGeometry(yardl::binary::CodedOutputStream& stream, petsird::ScannerGeometry const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ScannerGeometry>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<petsird::ReplicatedDetectorModule, petsird::binary::WriteReplicatedDetectorModule>(stream, value.replicated_modules);
  yardl::binary::WriteVector<uint32_t, yardl::binary::WriteInteger>(stream, value.ids);
  yardl::binary::WriteOptional<std::vector<petsird::GenericSolidVolume>, yardl::binary::WriteVector<petsird::GenericSolidVolume, petsird::binary::WriteGenericSolidVolume>>(stream, value.non_detecting_volumes);
}

[[maybe_unused]] void ReadScannerGeometry(yardl::binary::CodedInputStream& stream, petsird::ScannerGeometry& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ScannerGeometry>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<petsird::ReplicatedDetectorModule, petsird::binary::ReadReplicatedDetectorModule>(stream, value.replicated_modules);
  yardl::binary::ReadVector<uint32_t, yardl::binary::ReadInteger>(stream, value.ids);
  yardl::binary::ReadOptional<std::vector<petsird::GenericSolidVolume>, yardl::binary::ReadVector<petsird::GenericSolidVolume, petsird::binary::ReadGenericSolidVolume>>(stream, value.non_detecting_volumes);
}

[[maybe_unused]] void WriteSubject(yardl::binary::CodedOutputStream& stream, petsird::Subject const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Subject>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.name);
  yardl::binary::WriteString(stream, value.id);
}

[[maybe_unused]] void ReadSubject(yardl::binary::CodedInputStream& stream, petsird::Subject& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Subject>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.name);
  yardl::binary::ReadString(stream, value.id);
}

[[maybe_unused]] void WriteInstitution(yardl::binary::CodedOutputStream& stream, petsird::Institution const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Institution>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteString(stream, value.address);
}

[[maybe_unused]] void ReadInstitution(yardl::binary::CodedInputStream& stream, petsird::Institution& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Institution>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadString(stream, value.address);
}

[[maybe_unused]] void WriteExamInformation(yardl::binary::CodedOutputStream& stream, petsird::ExamInformation const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ExamInformation>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteSubject(stream, value.subject);
  petsird::binary::WriteInstitution(stream, value.institution);
  yardl::binary::WriteOptional<std::string, yardl::binary::WriteString>(stream, value.protocol);
  yardl::binary::WriteOptional<yardl::DateTime, yardl::binary::WriteDateTime>(stream, value.start_of_acquisition);
}

[[maybe_unused]] void ReadExamInformation(yardl::binary::CodedInputStream& stream, petsird::ExamInformation& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ExamInformation>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadSubject(stream, value.subject);
  petsird::binary::ReadInstitution(stream, value.institution);
  yardl::binary::ReadOptional<std::string, yardl::binary::ReadString>(stream, value.protocol);
  yardl::binary::ReadOptional<yardl::DateTime, yardl::binary::ReadDateTime>(stream, value.start_of_acquisition);
}

[[maybe_unused]] void WriteDirection(yardl::binary::CodedOutputStream& stream, petsird::Direction const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Direction>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3>(stream, value.c);
}

[[maybe_unused]] void ReadDirection(yardl::binary::CodedInputStream& stream, petsird::Direction& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Direction>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3>(stream, value.c);
}

[[maybe_unused]] void WriteDirectionMatrix(yardl::binary::CodedOutputStream& stream, petsird::DirectionMatrix const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::DirectionMatrix>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteFixedNDArray<float, yardl::binary::WriteFloatingPoint, 3, 3>(stream, value.matrix);
}

[[maybe_unused]] void ReadDirectionMatrix(yardl::binary::CodedInputStream& stream, petsird::DirectionMatrix& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::DirectionMatrix>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadFixedNDArray<float, yardl::binary::ReadFloatingPoint, 3, 3>(stream, value.matrix);
}

[[maybe_unused]] void WriteAtom(yardl::binary::CodedOutputStream& stream, petsird::Atom const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Atom>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.mass_number);
  yardl::binary::WriteInteger(stream, value.atomic_number);
}

[[maybe_unused]] void ReadAtom(yardl::binary::CodedInputStream& stream, petsird::Atom& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Atom>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.mass_number);
  yardl::binary::ReadInteger(stream, value.atomic_number);
}

[[maybe_unused]] void WriteBulkMaterial(yardl::binary::CodedOutputStream& stream, petsird::BulkMaterial const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BulkMaterial>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.id);
  yardl::binary::WriteString(stream, value.name);
  yardl::binary::WriteFloatingPoint(stream, value.density);
  yardl::binary::WriteVector<petsird::Atom, petsird::binary::WriteAtom>(stream, value.atoms);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.mass_fractions);
}

[[maybe_unused]] void ReadBulkMaterial(yardl::binary::CodedInputStream& stream, petsird::BulkMaterial& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BulkMaterial>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.id);
  yardl::binary::ReadString(stream, value.name);
  yardl::binary::ReadFloatingPoint(stream, value.density);
  yardl::binary::ReadVector<petsird::Atom, petsird::binary::ReadAtom>(stream, value.atoms);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.mass_fractions);
}

[[maybe_unused]] void WriteScannerInformation(yardl::binary::CodedOutputStream& stream, petsird::ScannerInformation const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ScannerInformation>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteString(stream, value.model_name);
  petsird::binary::WriteScannerGeometry(stream, value.scanner_geometry);
  yardl::binary::WriteVector<petsird::BulkMaterial, petsird::binary::WriteBulkMaterial>(stream, value.bulk_materials);
  yardl::binary::WriteOptional<petsird::RigidTransformation, petsird::binary::WriteRigidTransformation>(stream, value.gantry_alignment);
  yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 1>(stream, value.tof_bin_edges);
  yardl::binary::WriteFloatingPoint(stream, value.tof_resolution);
  yardl::binary::WriteNDArray<float, yardl::binary::WriteFloatingPoint, 1>(stream, value.energy_bin_edges);
  yardl::binary::WriteFloatingPoint(stream, value.energy_resolution_at_511);
  yardl::binary::WriteInteger(stream, value.event_time_block_duration);
  yardl::binary::WriteEnum<petsird::CoincidencePolicy>(stream, value.coincidence_policy);
}

[[maybe_unused]] void ReadScannerInformation(yardl::binary::CodedInputStream& stream, petsird::ScannerInformation& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ScannerInformation>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadString(stream, value.model_name);
  petsird::binary::ReadScannerGeometry(stream, value.scanner_geometry);
  yardl::binary::ReadVector<petsird::BulkMaterial, petsird::binary::ReadBulkMaterial>(stream, value.bulk_materials);
  yardl::binary::ReadOptional<petsird::RigidTransformation, petsird::binary::ReadRigidTransformation>(stream, value.gantry_alignment);
  yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 1>(stream, value.tof_bin_edges);
  yardl::binary::ReadFloatingPoint(stream, value.tof_resolution);
  yardl::binary::ReadNDArray<float, yardl::binary::ReadFloatingPoint, 1>(stream, value.energy_bin_edges);
  yardl::binary::ReadFloatingPoint(stream, value.energy_resolution_at_511);
  yardl::binary::ReadInteger(stream, value.event_time_block_duration);
  yardl::binary::ReadEnum<petsird::CoincidencePolicy>(stream, value.coincidence_policy);
}

[[maybe_unused]] void WriteHeader(yardl::binary::CodedOutputStream& stream, petsird::Header const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Header>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::WriteScannerInformation(stream, value.scanner);
  yardl::binary::WriteOptional<petsird::ExamInformation, petsird::binary::WriteExamInformation>(stream, value.exam);
}

[[maybe_unused]] void ReadHeader(yardl::binary::CodedInputStream& stream, petsird::Header& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::Header>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  petsird::binary::ReadScannerInformation(stream, value.scanner);
  yardl::binary::ReadOptional<petsird::ExamInformation, petsird::binary::ReadExamInformation>(stream, value.exam);
}

[[maybe_unused]] void WriteTripleEvent(yardl::binary::CodedOutputStream& stream, petsird::TripleEvent const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TripleEvent>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteArray<uint32_t, yardl::binary::WriteInteger, 3>(stream, value.detector_ids);
  yardl::binary::WriteArray<uint32_t, yardl::binary::WriteInteger, 2>(stream, value.tof_indices);
  yardl::binary::WriteArray<uint32_t, yardl::binary::WriteInteger, 3>(stream, value.energy_indices);
}

[[maybe_unused]] void ReadTripleEvent(yardl::binary::CodedInputStream& stream, petsird::TripleEvent& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TripleEvent>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadArray<uint32_t, yardl::binary::ReadInteger, 3>(stream, value.detector_ids);
  yardl::binary::ReadArray<uint32_t, yardl::binary::ReadInteger, 2>(stream, value.tof_indices);
  yardl::binary::ReadArray<uint32_t, yardl::binary::ReadInteger, 3>(stream, value.energy_indices);
}

[[maybe_unused]] void WriteEventTimeBlock(yardl::binary::CodedOutputStream& stream, petsird::EventTimeBlock const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::EventTimeBlock>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.start);
  yardl::binary::WriteVector<petsird::CoincidenceEvent, petsird::binary::WriteCoincidenceEvent>(stream, value.prompt_events);
  yardl::binary::WriteOptional<std::vector<petsird::CoincidenceEvent>, yardl::binary::WriteVector<petsird::CoincidenceEvent, petsird::binary::WriteCoincidenceEvent>>(stream, value.delayed_events);
  yardl::binary::WriteOptional<std::vector<petsird::TripleEvent>, yardl::binary::WriteVector<petsird::TripleEvent, petsird::binary::WriteTripleEvent>>(stream, value.triple_events);
}

[[maybe_unused]] void ReadEventTimeBlock(yardl::binary::CodedInputStream& stream, petsird::EventTimeBlock& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::EventTimeBlock>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.start);
  yardl::binary::ReadVector<petsird::CoincidenceEvent, petsird::binary::ReadCoincidenceEvent>(stream, value.prompt_events);
  yardl::binary::ReadOptional<std::vector<petsird::CoincidenceEvent>, yardl::binary::ReadVector<petsird::CoincidenceEvent, petsird::binary::ReadCoincidenceEvent>>(stream, value.delayed_events);
  yardl::binary::ReadOptional<std::vector<petsird::TripleEvent>, yardl::binary::ReadVector<petsird::TripleEvent, petsird::binary::ReadTripleEvent>>(stream, value.triple_events);
}

[[maybe_unused]] void WriteExternalSignalTimeBlock(yardl::binary::CodedOutputStream& stream, petsird::ExternalSignalTimeBlock const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ExternalSignalTimeBlock>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.start);
  yardl::binary::WriteInteger(stream, value.signal_id);
  yardl::binary::WriteVector<float, yardl::binary::WriteFloatingPoint>(stream, value.signal_values);
}

[[maybe_unused]] void ReadExternalSignalTimeBlock(yardl::binary::CodedInputStream& stream, petsird::ExternalSignalTimeBlock& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ExternalSignalTimeBlock>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.start);
  yardl::binary::ReadInteger(stream, value.signal_id);
  yardl::binary::ReadVector<float, yardl::binary::ReadFloatingPoint>(stream, value.signal_values);
}

[[maybe_unused]] void WriteBedMovementTimeBlock(yardl::binary::CodedOutputStream& stream, petsird::BedMovementTimeBlock const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BedMovementTimeBlock>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.start);
  petsird::binary::WriteRigidTransformation(stream, value.transform);
}

[[maybe_unused]] void ReadBedMovementTimeBlock(yardl::binary::CodedInputStream& stream, petsird::BedMovementTimeBlock& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::BedMovementTimeBlock>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.start);
  petsird::binary::ReadRigidTransformation(stream, value.transform);
}

[[maybe_unused]] void WriteGantryMovementTimeBlock(yardl::binary::CodedOutputStream& stream, petsird::GantryMovementTimeBlock const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::GantryMovementTimeBlock>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.start);
  petsird::binary::WriteRigidTransformation(stream, value.transform);
}

[[maybe_unused]] void ReadGantryMovementTimeBlock(yardl::binary::CodedInputStream& stream, petsird::GantryMovementTimeBlock& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::GantryMovementTimeBlock>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.start);
  petsird::binary::ReadRigidTransformation(stream, value.transform);
}

[[maybe_unused]] void WriteTimeBlock(yardl::binary::CodedOutputStream& stream, petsird::TimeBlock const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TimeBlock>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  WriteUnion<petsird::EventTimeBlock, petsird::binary::WriteEventTimeBlock, petsird::ExternalSignalTimeBlock, petsird::binary::WriteExternalSignalTimeBlock, petsird::BedMovementTimeBlock, petsird::binary::WriteBedMovementTimeBlock, petsird::GantryMovementTimeBlock, petsird::binary::WriteGantryMovementTimeBlock>(stream, value);
}

[[maybe_unused]] void ReadTimeBlock(yardl::binary::CodedInputStream& stream, petsird::TimeBlock& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TimeBlock>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  ReadUnion<petsird::EventTimeBlock, petsird::binary::ReadEventTimeBlock, petsird::ExternalSignalTimeBlock, petsird::binary::ReadExternalSignalTimeBlock, petsird::BedMovementTimeBlock, petsird::binary::ReadBedMovementTimeBlock, petsird::GantryMovementTimeBlock, petsird::binary::ReadGantryMovementTimeBlock>(stream, value);
}

[[maybe_unused]] void WriteExternalSignalType(yardl::binary::CodedOutputStream& stream, petsird::ExternalSignalType const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ExternalSignalType>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteEnum<petsird::ExternalSignalTypeEnum>(stream, value.type);
  yardl::binary::WriteString(stream, value.description);
  yardl::binary::WriteInteger(stream, value.id);
}

[[maybe_unused]] void ReadExternalSignalType(yardl::binary::CodedInputStream& stream, petsird::ExternalSignalType& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::ExternalSignalType>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadEnum<petsird::ExternalSignalTypeEnum>(stream, value.type);
  yardl::binary::ReadString(stream, value.description);
  yardl::binary::ReadInteger(stream, value.id);
}

[[maybe_unused]] void WriteTimeInterval(yardl::binary::CodedOutputStream& stream, petsird::TimeInterval const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TimeInterval>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteInteger(stream, value.start);
  yardl::binary::WriteInteger(stream, value.stop);
}

[[maybe_unused]] void ReadTimeInterval(yardl::binary::CodedInputStream& stream, petsird::TimeInterval& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TimeInterval>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadInteger(stream, value.start);
  yardl::binary::ReadInteger(stream, value.stop);
}

[[maybe_unused]] void WriteTimeFrameInformation(yardl::binary::CodedOutputStream& stream, petsird::TimeFrameInformation const& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TimeFrameInformation>::value) {
    yardl::binary::WriteTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::WriteVector<petsird::TimeInterval, petsird::binary::WriteTimeInterval>(stream, value.time_frames);
}

[[maybe_unused]] void ReadTimeFrameInformation(yardl::binary::CodedInputStream& stream, petsird::TimeFrameInformation& value) {
  if constexpr (yardl::binary::IsTriviallySerializable<petsird::TimeFrameInformation>::value) {
    yardl::binary::ReadTriviallySerializable(stream, value);
    return;
  }

  yardl::binary::ReadVector<petsird::TimeInterval, petsird::binary::ReadTimeInterval>(stream, value.time_frames);
}

} // namespace

void PETSIRDWriter::WriteHeaderImpl(petsird::Header const& value) {
  petsird::binary::WriteHeader(stream_, value);
}

void PETSIRDWriter::WriteTimeBlocksImpl(petsird::TimeBlock const& value) {
  yardl::binary::WriteBlock<petsird::TimeBlock, petsird::binary::WriteTimeBlock>(stream_, value);
}

void PETSIRDWriter::WriteTimeBlocksImpl(std::vector<petsird::TimeBlock> const& values) {
  if (!values.empty()) {
    yardl::binary::WriteVector<petsird::TimeBlock, petsird::binary::WriteTimeBlock>(stream_, values);
  }
}

void PETSIRDWriter::EndTimeBlocksImpl() {
  yardl::binary::WriteInteger(stream_, 0U);
}

void PETSIRDWriter::Flush() {
  stream_.Flush();
}

void PETSIRDWriter::CloseImpl() {
  stream_.Flush();
}

void PETSIRDReader::ReadHeaderImpl(petsird::Header& value) {
  petsird::binary::ReadHeader(stream_, value);
}

bool PETSIRDReader::ReadTimeBlocksImpl(petsird::TimeBlock& value) {
  bool read_block_successful = false;
  read_block_successful = yardl::binary::ReadBlock<petsird::TimeBlock, petsird::binary::ReadTimeBlock>(stream_, current_block_remaining_, value);
  return read_block_successful;
}

bool PETSIRDReader::ReadTimeBlocksImpl(std::vector<petsird::TimeBlock>& values) {
  yardl::binary::ReadBlocksIntoVector<petsird::TimeBlock, petsird::binary::ReadTimeBlock>(stream_, current_block_remaining_, values);
  return current_block_remaining_ != 0;
}

void PETSIRDReader::CloseImpl() {
  stream_.VerifyFinished();
}

} // namespace petsird::binary

