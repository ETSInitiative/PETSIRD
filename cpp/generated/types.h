// This file was generated by the "yardl" tool. DO NOT EDIT.

#pragma once
#include <array>
#include <complex>
#include <optional>
#include <unordered_map>
#include <variant>
#include <vector>

#include "yardl/yardl.h"

namespace petsird {
// All information about a coincidence event specified as identifiers or indices (i.e. discretized). Indices start from 0.
// TODO: this might take up too much space, so some/all of these could be combined in a single index if necessary.
struct CoincidenceEvent {
  // the pair of detector elements
  std::array<uint32_t, 2> detector_ids{};
  // an index into the tofBinEdges field in the ScannerInformation
  uint32_t tof_idx{};
  // a pair of indices into the energyBinEdges field in the ScannerInformation
  std::array<uint32_t, 2> energy_indices{};

  bool operator==(const CoincidenceEvent& other) const {
    return detector_ids == other.detector_ids &&
      tof_idx == other.tof_idx &&
      energy_indices == other.energy_indices;
  }

  bool operator!=(const CoincidenceEvent& other) const {
    return !(*this == other);
  }
};

// A shape filled with a uniform material
template <typename Shape>
struct SolidVolume {
  Shape shape{};
  // identifier referring to `ScannerInformation.bulkMaterials` list
  uint32_t material_id{};

  bool operator==(const SolidVolume& other) const {
    return shape == other.shape &&
      material_id == other.material_id;
  }

  bool operator!=(const SolidVolume& other) const {
    return !(*this == other);
  }
};

// 3D coordinates (in mm)
struct Coordinate {
  yardl::FixedNDArray<float, 3> c{};

  bool operator==(const Coordinate& other) const {
    return c == other.c;
  }

  bool operator!=(const Coordinate& other) const {
    return !(*this == other);
  }
};

// A box-shape specified by 8 corners (e.g. cuboid, wedge, etc.)
// TODO need to think about a clear definition of planes
// We do not want to have to check about intersection planes
// Potential mechanisms:
// - lexicographical ordering of corner coordinates?
// - first 4 coordinates give first plane, 5th and 6th need to define plane with first 2, etc.
struct BoxShape {
  std::array<petsird::Coordinate, 8> corners{};

  bool operator==(const BoxShape& other) const {
    return corners == other.corners;
  }

  bool operator!=(const BoxShape& other) const {
    return !(*this == other);
  }
};

using BoxSolidVolume = petsird::SolidVolume<petsird::BoxShape>;

// Annulus of certain thickness centered at [0,0,0] and oriented along the [0,0,1] axis
// in radians. An angle of 0 corresponds to the [1,0,0] axis, Pi/2 corresponds to the [0,1,0] axis.
struct AnnulusShape {
  // inner radius (in mm)
  float inner_radius{};
  // outer radius (in mm)
  float outer_radius{};
  // thickness of the annulus, i.e. length along the axis (in mm)
  float thickness{};
  // start-stop angle (in radians)
  std::array<float, 2> angular_range{};

  bool operator==(const AnnulusShape& other) const {
    return inner_radius == other.inner_radius &&
      outer_radius == other.outer_radius &&
      thickness == other.thickness &&
      angular_range == other.angular_range;
  }

  bool operator!=(const AnnulusShape& other) const {
    return !(*this == other);
  }
};

// Union of all possible shapes
using GeometricShape = std::variant<petsird::BoxShape, petsird::AnnulusShape>;

using GenericSolidVolume = petsird::SolidVolume<petsird::GeometricShape>;

// Rigid transformation, encoded via homogenous transformation
// transformed_coord = matrix * [c, 1] (where [c,1] is a column vector)
// with `c` of type `Coordinate`
struct RigidTransformation {
  yardl::FixedNDArray<float, 3, 4> matrix{};

  bool operator==(const RigidTransformation& other) const {
    return matrix == other.matrix;
  }

  bool operator!=(const RigidTransformation& other) const {
    return !(*this == other);
  }
};

// A list of identical objects at different locations
template <typename T>
struct ReplicatedObject {
  T object{};
  // list of transforms
  // constraint: length >= 1
  std::vector<petsird::RigidTransformation> transforms{};
  // list of unique ids for every replicated solid volume
  // constraint: size(transforms) == size(ids)
  std::vector<uint32_t> ids{};

  yardl::Size NumberOfObjects() const {
    return transforms.size();
  }

  bool operator==(const ReplicatedObject& other) const {
    return object == other.object &&
      transforms == other.transforms &&
      ids == other.ids;
  }

  bool operator!=(const ReplicatedObject& other) const {
    return !(*this == other);
  }
};

// A list of identical SolidVolumes<BoxShape> at different locations
using ReplicatedBoxSolidVolume = petsird::ReplicatedObject<petsird::BoxSolidVolume>;

// A list of identical SolidVolumes<BGeometricShape> at different locations
using ReplicatedGenericSolidVolume = petsird::ReplicatedObject<petsird::GenericSolidVolume>;

// Top-level detector structure, consisting of one or more lists of detecting elements (or "crystals")
// This allows having different types of detecting elements (e.g. for phoswich detectors)
// TODO this could be made into a hierarchical structure
struct DetectorModule {
  std::vector<petsird::ReplicatedBoxSolidVolume> detecting_elements{};
  // list of unique ids for every replicated solid volume
  // constraint: size(detectingElements) == size(detectingElementsIds)
  std::vector<uint32_t> detecting_element_ids{};
  // optional list describing shielding/optical reflectors etc
  std::vector<petsird::ReplicatedGenericSolidVolume> non_detecting_elements{};

  bool operator==(const DetectorModule& other) const {
    return detecting_elements == other.detecting_elements &&
      detecting_element_ids == other.detecting_element_ids &&
      non_detecting_elements == other.non_detecting_elements;
  }

  bool operator!=(const DetectorModule& other) const {
    return !(*this == other);
  }
};

// A list of identical modules at different locations
using ReplicatedDetectorModule = petsird::ReplicatedObject<petsird::DetectorModule>;

// Full definition of the geometry of the scanner, consisting of
// one of more types of modules replicated in space and (optional) other structures (e.g. side-shielding)
struct ScannerGeometry {
  // list of different types of replicated modules
  std::vector<petsird::ReplicatedDetectorModule> replicated_modules{};
  // list of unique ids for every replicated module
  // constraint: size(replicated_modules) == size(ids)
  std::vector<uint32_t> ids{};
  // shielding etc
  std::optional<std::vector<petsird::GenericSolidVolume>> non_detecting_volumes{};

  bool operator==(const ScannerGeometry& other) const {
    return replicated_modules == other.replicated_modules &&
      ids == other.ids &&
      non_detecting_volumes == other.non_detecting_volumes;
  }

  bool operator!=(const ScannerGeometry& other) const {
    return !(*this == other);
  }
};

struct Subject {
  std::optional<std::string> name{};
  std::string id{};

  bool operator==(const Subject& other) const {
    return name == other.name &&
      id == other.id;
  }

  bool operator!=(const Subject& other) const {
    return !(*this == other);
  }
};

struct Institution {
  std::string name{};
  std::string address{};

  bool operator==(const Institution& other) const {
    return name == other.name &&
      address == other.address;
  }

  bool operator!=(const Institution& other) const {
    return !(*this == other);
  }
};

// Items describing the exam (incomplete)
struct ExamInformation {
  petsird::Subject subject{};
  petsird::Institution institution{};
  std::optional<std::string> protocol{};
  std::optional<yardl::DateTime> start_of_acquisition{};

  bool operator==(const ExamInformation& other) const {
    return subject == other.subject &&
      institution == other.institution &&
      protocol == other.protocol &&
      start_of_acquisition == other.start_of_acquisition;
  }

  bool operator!=(const ExamInformation& other) const {
    return !(*this == other);
  }
};

// 3D direction vector (normalized to 1)
struct Direction {
  yardl::FixedNDArray<float, 3> c{};

  bool operator==(const Direction& other) const {
    return c == other.c;
  }

  bool operator!=(const Direction& other) const {
    return !(*this == other);
  }
};

// Orthonormal matrix
// direction_of_first_axis = matrix * [1, 0 ,0] (as a column vector)
struct DirectionMatrix {
  yardl::FixedNDArray<float, 3, 3> matrix{};

  bool operator==(const DirectionMatrix& other) const {
    return matrix == other.matrix;
  }

  bool operator!=(const DirectionMatrix& other) const {
    return !(*this == other);
  }
};

// Atom definition in terms of Z and A
struct Atom {
  // A
  uint32_t mass_number{};
  // Z
  uint32_t atomic_number{};

  bool operator==(const Atom& other) const {
    return mass_number == other.mass_number &&
      atomic_number == other.atomic_number;
  }

  bool operator!=(const Atom& other) const {
    return !(*this == other);
  }
};

// Specification of materials used in the scanner.
// TODO agree with vendors if this information can be supplied and to what accuracy
// Ideally this list should be reasonably accurate to be useful for Monte Carlo simulations, but can be approximate.
struct BulkMaterial {
  // unique id that can be used to refer to the material in voxelised maps etc
  uint32_t id{};
  // informative string, not standardised.
  // Expected examples:
  // detecting: BGO, LSO, LYSO, LaBr, GAGG, plastic
  // non-detecting: tungsten, lead
  std::string name{};
  // density of the material
  // Units: g/cc
  float density{};
  // List of atoms
  std::vector<petsird::Atom> atoms{};
  // List of massFractions for the atoms.
  // constraint: sum of massFractions should be 1
  // constraint:  size(atoms) == size(massFractions)
  std::vector<float> mass_fractions{};

  bool operator==(const BulkMaterial& other) const {
    return id == other.id &&
      name == other.name &&
      density == other.density &&
      atoms == other.atoms &&
      mass_fractions == other.mass_fractions;
  }

  bool operator!=(const BulkMaterial& other) const {
    return !(*this == other);
  }
};

// Type definition for how to encode how the scanner handles multiple coincidences when recording the prompts.
// Due to various effects (such as high count rate, prompt gammas), it is possible that multiple single
// events are detected within the coincidence window. This type encodes some different ways
// that this multiple events are handled, and recorded in the coincidence stream.
enum class CoincidencePolicy {
  // multiples will be rejected
  kRejectMultiples = 0,
  // multiples will be stored as a sequence of pairs, e.g. a triple leads to 3 pairs
  kStoreMultiplesAsPairs = 1,
  // other options, to be listed in the future
  kOther = 2,
};

struct ScannerInformation {
  std::string model_name{};
  // Geometric information for all detector elements
  // All coordinates are in the PET gantry coordinate system.
  petsird::ScannerGeometry scanner_geometry{};
  // List of materials present in the scanner geometry. The `material_id`s there will refer to the
  // identifiers in this list below.
  std::vector<petsird::BulkMaterial> bulk_materials{};
  // Fixed transformation to reference location for this scanner.
  // This field can be used to encode alignment with the CT or MRI gantry for instance.
  // The transformation should convert from the PET gantry coordinate system to the reference.
  // An empty field implies the identity transformation.
  std::optional<petsird::RigidTransformation> gantry_alignment{};
  // Edge information for TOF bins in mm (given as from first to last edge, so there is one more edge than the number of bins)
  // 0 corresponds to the same arrival time. Negative numbers indicate that the first detector detected first.
  // For instance, a coincidence event is stored as 2 detectorIds, denoting the arrival time at the first
  // detector t1 and the arrival time at the second detector t2, we store (t1-t2)*c/2.
  // Note: for non-TOF scanners, this defines the coincidence window
  // TODO: this currently assumes equal size for each TOF bin, but some scanners "stretch" TOF bins depending on length of LOR
  yardl::NDArray<float, 1> tof_bin_edges{};
  // TOF resolution (as FWHM) in mm
  // Scanner coincidence timing resolution (CTR) without tof-binning
  float tof_resolution{};
  // Edge information for energy windows in keV (given as from first to last edge, so there is one more edge than the number of bins)
  yardl::NDArray<float, 1> energy_bin_edges{};
  // FWHM of photopeak for incoming gamma of 511 keV, expressed as a ratio w.r.t. 511
  float energy_resolution_at_511{};
  // duration of each event time block in ms
  uint32_t event_time_block_duration{};
  // Encode how the scanner handles multiple coincidences
  petsird::CoincidencePolicy coincidence_policy{};

  yardl::Size NumberOfTOFBins() const {
    return yardl::size(tof_bin_edges) - 1ULL;
  }

  yardl::Size NumberOfEnergyBins() const {
    return yardl::size(energy_bin_edges) - 1ULL;
  }

  bool operator==(const ScannerInformation& other) const {
    return model_name == other.model_name &&
      scanner_geometry == other.scanner_geometry &&
      bulk_materials == other.bulk_materials &&
      gantry_alignment == other.gantry_alignment &&
      tof_bin_edges == other.tof_bin_edges &&
      tof_resolution == other.tof_resolution &&
      energy_bin_edges == other.energy_bin_edges &&
      energy_resolution_at_511 == other.energy_resolution_at_511 &&
      event_time_block_duration == other.event_time_block_duration &&
      coincidence_policy == other.coincidence_policy;
  }

  bool operator!=(const ScannerInformation& other) const {
    return !(*this == other);
  }
};

struct Header {
  petsird::ScannerInformation scanner{};
  std::optional<petsird::ExamInformation> exam{};

  bool operator==(const Header& other) const {
    return scanner == other.scanner &&
      exam == other.exam;
  }

  bool operator!=(const Header& other) const {
    return !(*this == other);
  }
};

// All information about a triple event specified as identifiers or indices (i.e. discretized).
struct TripleEvent {
  std::array<uint32_t, 3> detector_ids{};
  // timing differences (converted to mm) w.r.t. first event, stored as
  // indices into the tofBinEdges field in the ScannerInformation
  // Note: only 2, corresponding to the arrival time differences of the second and third detectorId
  // listed w.r.t. the first detectorId
  std::array<uint32_t, 2> tof_indices{};
  // indices for each single event into the energyBinEdges field in the ScannerInformation
  std::array<uint32_t, 3> energy_indices{};

  bool operator==(const TripleEvent& other) const {
    return detector_ids == other.detector_ids &&
      tof_indices == other.tof_indices &&
      energy_indices == other.energy_indices;
  }

  bool operator!=(const TripleEvent& other) const {
    return !(*this == other);
  }
};

struct EventTimeBlock {
  // start time since ExamInformation.startOfAcquisition in ms
  // Note: duration is given by ScannerInformation.eventTimeBlockDuration
  uint32_t start{};
  // TODO encode end time?
  // list of prompts in this time block
  // TODO might be better to use !array
  std::vector<petsird::CoincidenceEvent> prompt_events{};
  // optional list of delayed coincidences in this time block
  std::optional<std::vector<petsird::CoincidenceEvent>> delayed_events{};
  // optional list of triple coincidences in this time block
  std::optional<std::vector<petsird::TripleEvent>> triple_events{};

  bool operator==(const EventTimeBlock& other) const {
    return start == other.start &&
      prompt_events == other.prompt_events &&
      delayed_events == other.delayed_events &&
      triple_events == other.triple_events;
  }

  bool operator!=(const EventTimeBlock& other) const {
    return !(*this == other);
  }
};

struct ExternalSignalTimeBlock {
  // start time since ExamInformation.startOfAcquisition in ms
  uint32_t start{};
  // refer to ExternalSignalType.id
  uint32_t signal_id{};
  // Note for triggers, this field is to be ignored
  std::vector<float> signal_values{};

  bool operator==(const ExternalSignalTimeBlock& other) const {
    return start == other.start &&
      signal_id == other.signal_id &&
      signal_values == other.signal_values;
  }

  bool operator!=(const ExternalSignalTimeBlock& other) const {
    return !(*this == other);
  }
};

struct BedMovementTimeBlock {
  // start time since ExamInformation.startOfAcquisition in ms
  uint32_t start{};
  petsird::RigidTransformation transform{};

  bool operator==(const BedMovementTimeBlock& other) const {
    return start == other.start &&
      transform == other.transform;
  }

  bool operator!=(const BedMovementTimeBlock& other) const {
    return !(*this == other);
  }
};

struct GantryMovementTimeBlock {
  // start time since ExamInformation.startOfAcquisition in ms
  uint32_t start{};
  petsird::RigidTransformation transform{};

  bool operator==(const GantryMovementTimeBlock& other) const {
    return start == other.start &&
      transform == other.transform;
  }

  bool operator!=(const GantryMovementTimeBlock& other) const {
    return !(*this == other);
  }
};

// types of timeBlocks
// TODO more types could be needed
using TimeBlock = std::variant<petsird::EventTimeBlock, petsird::ExternalSignalTimeBlock, petsird::BedMovementTimeBlock, petsird::GantryMovementTimeBlock>;

enum class ExternalSignalTypeEnum {
  kEcgTrace = 0,
  kEcgTrigger = 1,
  kRespTrace = 2,
  kRespTrigger = 3,
  kOtherMotionSignal = 4,
  kOtherMotionTrigger = 5,
  kExternalSync = 6,
  // other options, to be listed in the future
  kOther = 7,
};

struct ExternalSignalType {
  petsird::ExternalSignalTypeEnum type{};
  std::string description{};
  uint32_t id{};

  bool operator==(const ExternalSignalType& other) const {
    return type == other.type &&
      description == other.description &&
      id == other.id;
  }

  bool operator!=(const ExternalSignalType& other) const {
    return !(*this == other);
  }
};

// Time interval in milliseconds since start of acquisition
struct TimeInterval {
  uint32_t start{};
  uint32_t stop{};

  bool operator==(const TimeInterval& other) const {
    return start == other.start &&
      stop == other.stop;
  }

  bool operator!=(const TimeInterval& other) const {
    return !(*this == other);
  }
};

// A sequence of time intervals (could be consecutive)
struct TimeFrameInformation {
  std::vector<petsird::TimeInterval> time_frames{};

  yardl::Size NumberOfTimeFrames() const {
    return time_frames.size();
  }

  bool operator==(const TimeFrameInformation& other) const {
    return time_frames == other.time_frames;
  }

  bool operator!=(const TimeFrameInformation& other) const {
    return !(*this == other);
  }
};

} // namespace petsird

