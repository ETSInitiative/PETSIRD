// This file was generated by the "yardl" tool. DO NOT EDIT.

#include "protocols.h"

#ifdef _MSC_VER
#define unlikely(x) x
#else
#define unlikely(x) __builtin_expect((x), 0)
#endif

namespace petsird {
namespace {
void PETSIRDWriterBaseInvalidState(uint8_t attempted, [[maybe_unused]] bool end, uint8_t current) {
  std::string expected_method;
  switch (current) {
  case 0: expected_method = "WriteHeader()"; break;
  case 1: expected_method = "WriteTimeBlocks() or EndTimeBlocks()"; break;
  }
  std::string attempted_method;
  switch (attempted) {
  case 0: attempted_method = "WriteHeader()"; break;
  case 1: attempted_method = end ? "EndTimeBlocks()" : "WriteTimeBlocks()"; break;
  case 2: attempted_method = "Close()"; break;
  }
  throw std::runtime_error("Expected call to " + expected_method + " but received call to " + attempted_method + " instead.");
}

void PETSIRDReaderBaseInvalidState(uint8_t attempted, uint8_t current) {
  auto f = [](uint8_t i) -> std::string {
    switch (i/2) {
    case 0: return "ReadHeader()";
    case 1: return "ReadTimeBlocks()";
    case 2: return "Close()";
    default: return "<unknown>";
    }
  };
  throw std::runtime_error("Expected call to " + f(current) + " but received call to " + f(attempted) + " instead.");
}

} // namespace 

std::string PETSIRDWriterBase::schema_ = R"({"protocol":{"name":"PETSIRD","sequence":[{"name":"header","type":"PETSIRD.Header"},{"name":"timeBlocks","type":{"stream":{"items":"PETSIRD.TimeBlock"}}}]},"types":[{"name":"AnnulusShape","fields":[{"name":"innerRadius","type":"float32"},{"name":"outerRadius","type":"float32"},{"name":"thickness","type":"float32"},{"name":"angularRange","type":{"vector":{"items":"float32","length":2}}}]},{"name":"Atom","fields":[{"name":"massNumber","type":"uint32"},{"name":"atomicNumber","type":"uint32"}]},{"name":"BedMovementTimeBlock","fields":[{"name":"start","type":"uint32"},{"name":"transform","type":"PETSIRD.RigidTransformation"}]},{"name":"BoxShape","fields":[{"name":"corners","type":{"vector":{"items":"PETSIRD.Coordinate","length":8}}}]},{"name":"BoxSolidVolume","type":{"name":"PETSIRD.SolidVolume","typeArguments":["PETSIRD.BoxShape"]}},{"name":"BulkMaterial","fields":[{"name":"id","type":"uint32"},{"name":"name","type":"string"},{"name":"density","type":"float32"},{"name":"atoms","type":{"vector":{"items":"PETSIRD.Atom"}}},{"name":"massFractions","type":{"vector":{"items":"float32"}}}]},{"name":"CoincidenceEvent","fields":[{"name":"detectorIds","type":{"vector":{"items":"uint32","length":2}}},{"name":"tofIdx","type":"uint32"},{"name":"energyIndices","type":{"vector":{"items":"uint32","length":2}}}]},{"name":"CoincidencePolicy","values":[{"symbol":"rejectMultiples","value":0},{"symbol":"storeMultiplesAsPairs","value":1},{"symbol":"other","value":2}]},{"name":"Coordinate","fields":[{"name":"c","type":{"array":{"items":"float32","dimensions":[{"length":3}]}}}]},{"name":"DetectorModule","fields":[{"name":"detectingElements","type":{"vector":{"items":"PETSIRD.ReplicatedBoxSolidVolume"}}},{"name":"detectingElementIds","type":{"vector":{"items":"uint32"}}},{"name":"nonDetectingElements","type":{"vector":{"items":"PETSIRD.ReplicatedGenericSolidVolume"}}}]},{"name":"EventTimeBlock","fields":[{"name":"start","type":"uint32"},{"name":"promptEvents","type":{"vector":{"items":"PETSIRD.CoincidenceEvent"}}},{"name":"delayedEvents","type":[null,{"vector":{"items":"PETSIRD.CoincidenceEvent"}}]},{"name":"tripleEvents","type":[null,{"vector":{"items":"PETSIRD.TripleEvent"}}]}]},{"name":"ExamInformation","fields":[{"name":"subject","type":"PETSIRD.Subject"},{"name":"institution","type":"PETSIRD.Institution"},{"name":"protocol","type":[null,"string"]},{"name":"startOfAcquisition","type":[null,"datetime"]}]},{"name":"ExternalSignalTimeBlock","fields":[{"name":"start","type":"uint32"},{"name":"signalID","type":"uint32"},{"name":"signalValues","type":{"vector":{"items":"float32"}}}]},{"name":"GantryMovementTimeBlock","fields":[{"name":"start","type":"uint32"},{"name":"transform","type":"PETSIRD.RigidTransformation"}]},{"name":"GenericSolidVolume","type":{"name":"PETSIRD.SolidVolume","typeArguments":["PETSIRD.GeometricShape"]}},{"name":"GeometricShape","type":[{"tag":"BoxShape","type":"PETSIRD.BoxShape"},{"tag":"AnnulusShape","type":"PETSIRD.AnnulusShape"}]},{"name":"Header","fields":[{"name":"scanner","type":"PETSIRD.ScannerInformation"},{"name":"exam","type":[null,"PETSIRD.ExamInformation"]}]},{"name":"Institution","fields":[{"name":"name","type":"string"},{"name":"address","type":"string"}]},{"name":"ReplicatedBoxSolidVolume","type":{"name":"PETSIRD.ReplicatedObject","typeArguments":["PETSIRD.BoxSolidVolume"]}},{"name":"ReplicatedDetectorModule","type":{"name":"PETSIRD.ReplicatedObject","typeArguments":["PETSIRD.DetectorModule"]}},{"name":"ReplicatedGenericSolidVolume","type":{"name":"PETSIRD.ReplicatedObject","typeArguments":["PETSIRD.GenericSolidVolume"]}},{"name":"ReplicatedObject","typeParameters":["T"],"fields":[{"name":"object","type":"T"},{"name":"transforms","type":{"vector":{"items":"PETSIRD.RigidTransformation"}}},{"name":"ids","type":{"vector":{"items":"uint32"}}}]},{"name":"RigidTransformation","fields":[{"name":"matrix","type":{"array":{"items":"float32","dimensions":[{"length":3},{"length":4}]}}}]},{"name":"ScannerGeometry","fields":[{"name":"replicatedModules","type":{"vector":{"items":"PETSIRD.ReplicatedDetectorModule"}}},{"name":"ids","type":{"vector":{"items":"uint32"}}},{"name":"nonDetectingVolumes","type":[null,{"vector":{"items":"PETSIRD.GenericSolidVolume"}}]}]},{"name":"ScannerInformation","fields":[{"name":"modelName","type":"string"},{"name":"scannerGeometry","type":"PETSIRD.ScannerGeometry"},{"name":"bulkMaterials","type":{"vector":{"items":"PETSIRD.BulkMaterial"}}},{"name":"gantryAlignment","type":[null,"PETSIRD.RigidTransformation"]},{"name":"tofBinEdges","type":{"array":{"items":"float32","dimensions":1}}},{"name":"tofResolution","type":"float32"},{"name":"energyBinEdges","type":{"array":{"items":"float32","dimensions":1}}},{"name":"energyResolutionAt511","type":"float32"},{"name":"eventTimeBlockDuration","type":"uint32"},{"name":"coincidencePolicy","type":"PETSIRD.CoincidencePolicy"}]},{"name":"SolidVolume","typeParameters":["Shape"],"fields":[{"name":"shape","type":"Shape"},{"name":"materialId","type":"uint32"}]},{"name":"Subject","fields":[{"name":"name","type":[null,"string"]},{"name":"id","type":"string"}]},{"name":"TimeBlock","type":[{"tag":"EventTimeBlock","type":"PETSIRD.EventTimeBlock"},{"tag":"ExternalSignalTimeBlock","type":"PETSIRD.ExternalSignalTimeBlock"},{"tag":"BedMovementTimeBlock","type":"PETSIRD.BedMovementTimeBlock"},{"tag":"GantryMovementTimeBlock","type":"PETSIRD.GantryMovementTimeBlock"}]},{"name":"TripleEvent","fields":[{"name":"detectorIds","type":{"vector":{"items":"uint32","length":3}}},{"name":"tofIndices","type":{"vector":{"items":"uint32","length":2}}},{"name":"energyIndices","type":{"vector":{"items":"uint32","length":3}}}]}]})";

std::vector<std::string> PETSIRDWriterBase::previous_schemas_ = {
};

std::string PETSIRDWriterBase::SchemaFromVersion(Version version) {
  switch (version) {
  case Version::Current: return PETSIRDWriterBase::schema_; break;
  default: throw std::runtime_error("The version does not correspond to any schema supported by protocol PETSIRD.");
  }

}
void PETSIRDWriterBase::WriteHeader(petsird::Header const& value) {
  if (unlikely(state_ != 0)) {
    PETSIRDWriterBaseInvalidState(0, false, state_);
  }

  WriteHeaderImpl(value);
  state_ = 1;
}

void PETSIRDWriterBase::WriteTimeBlocks(petsird::TimeBlock const& value) {
  if (unlikely(state_ != 1)) {
    PETSIRDWriterBaseInvalidState(1, false, state_);
  }

  WriteTimeBlocksImpl(value);
}

void PETSIRDWriterBase::WriteTimeBlocks(std::vector<petsird::TimeBlock> const& values) {
  if (unlikely(state_ != 1)) {
    PETSIRDWriterBaseInvalidState(1, false, state_);
  }

  WriteTimeBlocksImpl(values);
}

void PETSIRDWriterBase::EndTimeBlocks() {
  if (unlikely(state_ != 1)) {
    PETSIRDWriterBaseInvalidState(1, true, state_);
  }

  EndTimeBlocksImpl();
  state_ = 2;
}

// fallback implementation
void PETSIRDWriterBase::WriteTimeBlocksImpl(std::vector<petsird::TimeBlock> const& values) {
  for (auto const& v : values) {
    WriteTimeBlocksImpl(v);
  }
}

void PETSIRDWriterBase::Close() {
  if (unlikely(state_ != 2)) {
    PETSIRDWriterBaseInvalidState(2, false, state_);
  }

  CloseImpl();
}

std::string PETSIRDReaderBase::schema_ = PETSIRDWriterBase::schema_;

std::vector<std::string> PETSIRDReaderBase::previous_schemas_ = PETSIRDWriterBase::previous_schemas_;

Version PETSIRDReaderBase::VersionFromSchema(std::string const& schema) {
  if (schema == PETSIRDWriterBase::schema_) {
    return Version::Current;
  }
  throw std::runtime_error("The schema does not match any version supported by protocol PETSIRD.");
}
void PETSIRDReaderBase::ReadHeader(petsird::Header& value) {
  if (unlikely(state_ != 0)) {
    PETSIRDReaderBaseInvalidState(0, state_);
  }

  ReadHeaderImpl(value);
  state_ = 2;
}

bool PETSIRDReaderBase::ReadTimeBlocks(petsird::TimeBlock& value) {
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      return false;
    }
    PETSIRDReaderBaseInvalidState(2, state_);
  }

  bool result = ReadTimeBlocksImpl(value);
  if (!result) {
    state_ = 4;
  }
  return result;
}

bool PETSIRDReaderBase::ReadTimeBlocks(std::vector<petsird::TimeBlock>& values) {
  if (values.capacity() == 0) {
    throw std::runtime_error("vector must have a nonzero capacity.");
  }
  if (unlikely(state_ != 2)) {
    if (state_ == 3) {
      state_ = 4;
      values.clear();
      return false;
    }
    PETSIRDReaderBaseInvalidState(2, state_);
  }

  if (!ReadTimeBlocksImpl(values)) {
    state_ = 3;
    return values.size() > 0;
  }
  return true;
}

// fallback implementation
bool PETSIRDReaderBase::ReadTimeBlocksImpl(std::vector<petsird::TimeBlock>& values) {
  size_t i = 0;
  while (true) {
    if (i == values.size()) {
      values.resize(i + 1);
    }
    if (!ReadTimeBlocksImpl(values[i])) {
      values.resize(i);
      return false;
    }
    i++;
    if (i == values.capacity()) {
      return true;
    }
  }
}

void PETSIRDReaderBase::Close() {
  if (unlikely(state_ != 4)) {
    if (state_ == 3) {
      state_ = 4;
    } else {
      PETSIRDReaderBaseInvalidState(4, state_);
    }
  }

  CloseImpl();
}
void PETSIRDReaderBase::CopyTo(PETSIRDWriterBase& writer, size_t time_blocks_buffer_size) {
  {
    petsird::Header value;
    ReadHeader(value);
    writer.WriteHeader(value);
  }
  if (time_blocks_buffer_size > 1) {
    std::vector<petsird::TimeBlock> values;
    values.reserve(time_blocks_buffer_size);
    while(ReadTimeBlocks(values)) {
      writer.WriteTimeBlocks(values);
    }
    writer.EndTimeBlocks();
  } else {
    petsird::TimeBlock value;
    while(ReadTimeBlocks(value)) {
      writer.WriteTimeBlocks(value);
    }
    writer.EndTimeBlocks();
  }
}
} // namespace petsird
