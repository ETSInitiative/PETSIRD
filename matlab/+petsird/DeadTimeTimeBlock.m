% This file was generated by the "yardl" tool. DO NOT EDIT.

classdef DeadTimeTimeBlock < handle
  properties
    % time interval for this time block
    time_interval
    % Singles dead-time array for the time interval, stored as fractions of "alive time"
    % (1 means no dead-time, 0 means no detected counts)
    % If sizeOfEnergyIdxDimension == 1, the fraction is assumed to be the same
    % for all energy windows.
    % Constraint: sizeOfDetectorIdDimension == number of all possible unique DetectorIds
    % Constraint: (sizeOfEnergyIdxDimension == 1) or (sizeOfEnergyIdxDimension == ScannerInformation.numberOfEnergyBins)
    singles_alive_time_fraction
    % coincidence dead-time array for 2 modules in coincidence, stored as fractions of "alive time"
    % (1 means no dead-time, 0 means no detected coincidences)
    % If the size of this 2D array is (1,1), it is assumed that the corresponding alive-fraction is the same for all modules.
    % Constraint: size(moduleCoincidenceAliveTimeFraction, 0) == 1 or total number of modules of all types
    % Constraint: size(moduleCoincidenceAliveTimeFraction, 1) == 1 or total number of modules of all types
    module_coincidence_alive_time_fraction
  end

  methods
    function self = DeadTimeTimeBlock(kwargs)
      arguments
        kwargs.time_interval = petsird.TimeInterval();
        kwargs.singles_alive_time_fraction = single.empty();
        kwargs.module_coincidence_alive_time_fraction = single.empty();
      end
      self.time_interval = kwargs.time_interval;
      self.singles_alive_time_fraction = kwargs.singles_alive_time_fraction;
      self.module_coincidence_alive_time_fraction = kwargs.module_coincidence_alive_time_fraction;
    end

    function res = size_of_detector_id_dimension(self)
      res = size(self.singles_alive_time_fraction, ndims(self.singles_alive_time_fraction)-(0));
      return
    end

    function res = size_of_energy_idx_dimension(self)
      res = size(self.singles_alive_time_fraction, ndims(self.singles_alive_time_fraction)-(1));
      return
    end


    function res = eq(self, other)
      res = ...
        isa(other, "petsird.DeadTimeTimeBlock") && ...
        isequal({self.time_interval}, {other.time_interval}) && ...
        isequal({self.singles_alive_time_fraction}, {other.singles_alive_time_fraction}) && ...
        isequal({self.module_coincidence_alive_time_fraction}, {other.module_coincidence_alive_time_fraction});
    end

    function res = ne(self, other)
      res = ~self.eq(other);
    end

    function res = isequal(self, other)
      res = all(eq(self, other));
    end
  end

  methods (Static)
    function z = zeros(varargin)
      elem = petsird.DeadTimeTimeBlock();
      if nargin == 0
        z = elem;
        return;
      end
      sz = [varargin{:}];
      if isscalar(sz)
        sz = [sz, sz];
      end
      z = reshape(repelem(elem, prod(sz)), sz);
    end
  end
end
