% This file was generated by the "yardl" tool. DO NOT EDIT.

classdef ScannerInformation < handle
  properties
    model_name
    % Geometric information for all detector elements
    % All coordinates are in the PET gantry coordinate system.
    scanner_geometry
    % List of materials present in the scanner geometry. The `material_id`s there will refer to the
    % identifiers in this list below.
    bulk_materials
    % Fixed transformation to reference location for this scanner.
    % This field can be used to encode alignment with the CT or MRI gantry for instance.
    % The transformation should convert from the PET gantry coordinate system to the reference.
    % An empty field implies the identity transformation.
    gantry_alignment
    % Edge information for TOF bins in mm (given as from first to last edge, so there is one more edge than the number of bins)
    % 0 corresponds to the same arrival time. Negative numbers indicate that the first detector detected first.
    % For instance, a coincidence event is stored as 2 detectorIds, denoting the arrival time at the first
    % detector t1 and the arrival time at the second detector t2, we store (t1-t2)*c/2.
    % Note: for non-TOF scanners, this defines the coincidence window
    % TODO: this currently assumes equal size for each TOF bin, but some scanners "stretch" TOF bins depending on length of LOR
    tof_bin_edges
    % TOF resolution (as FWHM) in mm
    % Scanner coincidence timing resolution (CTR) without tof-binning
    tof_resolution
    % Edge information for energy windows in keV (given as from first to last edge, so there is one more edge than the number of bins)
    energy_bin_edges
    % FWHM of photopeak for incoming gamma of 511 keV, expressed as a ratio w.r.t. 511
    energy_resolution_at_511
    % duration of each event time block in ms
    event_time_block_duration
    % Encode how the scanner handles multiple coincidences
    coincidence_policy
    % coincidence detection efficiencies
    detection_efficiencies
  end

  methods
    function self = ScannerInformation(kwargs)
      arguments
        kwargs.model_name = "";
        kwargs.scanner_geometry = petsird.ScannerGeometry();
        kwargs.bulk_materials = petsird.BulkMaterial.empty();
        kwargs.gantry_alignment = yardl.None;
        kwargs.tof_bin_edges = single.empty();
        kwargs.tof_resolution = single(0);
        kwargs.energy_bin_edges = single.empty();
        kwargs.energy_resolution_at_511 = single(0);
        kwargs.event_time_block_duration = uint32(0);
        kwargs.coincidence_policy = petsird.CoincidencePolicy.REJECT_MULTIPLES;
        kwargs.detection_efficiencies = petsird.DetectionEfficiencies();
      end
      self.model_name = kwargs.model_name;
      self.scanner_geometry = kwargs.scanner_geometry;
      self.bulk_materials = kwargs.bulk_materials;
      self.gantry_alignment = kwargs.gantry_alignment;
      self.tof_bin_edges = kwargs.tof_bin_edges;
      self.tof_resolution = kwargs.tof_resolution;
      self.energy_bin_edges = kwargs.energy_bin_edges;
      self.energy_resolution_at_511 = kwargs.energy_resolution_at_511;
      self.event_time_block_duration = kwargs.event_time_block_duration;
      self.coincidence_policy = kwargs.coincidence_policy;
      self.detection_efficiencies = kwargs.detection_efficiencies;
    end

    function res = number_of_tof_bins(self)
      res = numel(self.tof_bin_edges) - 1;
      return
    end

    function res = number_of_energy_bins(self)
      res = numel(self.energy_bin_edges) - 1;
      return
    end


    function res = eq(self, other)
      res = ...
        isa(other, "petsird.ScannerInformation") && ...
        isequal({self.model_name}, {other.model_name}) && ...
        isequal({self.scanner_geometry}, {other.scanner_geometry}) && ...
        isequal({self.bulk_materials}, {other.bulk_materials}) && ...
        isequal({self.gantry_alignment}, {other.gantry_alignment}) && ...
        isequal({self.tof_bin_edges}, {other.tof_bin_edges}) && ...
        isequal({self.tof_resolution}, {other.tof_resolution}) && ...
        isequal({self.energy_bin_edges}, {other.energy_bin_edges}) && ...
        isequal({self.energy_resolution_at_511}, {other.energy_resolution_at_511}) && ...
        isequal({self.event_time_block_duration}, {other.event_time_block_duration}) && ...
        isequal({self.coincidence_policy}, {other.coincidence_policy}) && ...
        isequal({self.detection_efficiencies}, {other.detection_efficiencies});
    end

    function res = ne(self, other)
      res = ~self.eq(other);
    end

    function res = isequal(self, other)
      res = all(eq(self, other));
    end
  end

  methods (Static)
    function z = zeros(varargin)
      elem = petsird.ScannerInformation();
      if nargin == 0
        z = elem;
        return;
      end
      sz = [varargin{:}];
      if isscalar(sz)
        sz = [sz, sz];
      end
      z = reshape(repelem(elem, prod(sz)), sz);
    end
  end
end
