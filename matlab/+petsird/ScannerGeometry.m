% This file was generated by the "yardl" tool. DO NOT EDIT.

classdef ScannerGeometry < handle
  % Full definition of the geometry of the scanner, consisting of
  % one of more types of modules replicated in space and (optional) other structures (e.g. side-shielding)
  properties
    % list of different types of replicated modules
    replicated_modules
    % list of unique ids for every replicated module
    % constraint: size(replicated_modules) == size(ids)
    ids
    % shielding etc
    non_detecting_volumes
  end

  methods
    function self = ScannerGeometry(kwargs)
      arguments
        kwargs.replicated_modules = petsird.ReplicatedDetectorModule.empty();
        kwargs.ids = uint32.empty();
        kwargs.non_detecting_volumes = yardl.None;
      end
      self.replicated_modules = kwargs.replicated_modules;
      self.ids = kwargs.ids;
      self.non_detecting_volumes = kwargs.non_detecting_volumes;
    end

    function res = eq(self, other)
      res = ...
        isa(other, "petsird.ScannerGeometry") && ...
        isequal({self.replicated_modules}, {other.replicated_modules}) && ...
        isequal({self.ids}, {other.ids}) && ...
        isequal({self.non_detecting_volumes}, {other.non_detecting_volumes});
    end

    function res = ne(self, other)
      res = ~self.eq(other);
    end

    function res = isequal(self, other)
      res = all(eq(self, other));
    end
  end

  methods (Static)
    function z = zeros(varargin)
      elem = petsird.ScannerGeometry();
      if nargin == 0
        z = elem;
        return;
      end
      sz = [varargin{:}];
      if isscalar(sz)
        sz = [sz, sz];
      end
      z = reshape(repelem(elem, prod(sz)), sz);
    end
  end
end
