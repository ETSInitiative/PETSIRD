# Symmetry Group Identifier Type
# Most PET scanners have some kind of geometric symmetry, e.g. rotation over a full
# module, or translation along the axis of the scanner. Module-pairs that are related
# by such a symmetry often have the same geometric detection efficiencies. PETSIRD
# calls this a "symmetry group" (SG). Each SG had a unique identifier (SGID).
# SGIDs are used to efficiently encode module-pair efficiencies etc.
SGID: uint

# Detection efficiencies for every DetectionBin if a particular type of module
# Constraint: size == number of all possible unique DetectionBins
DetectionBinEfficiencies: float[detectionBin]

# Efficiency for two detection bins in a pair of modules.
# This is one component (often called "geometric") of the detection efficiency model.
ModulePairEfficiencies: !record
  fields:
    # Detection efficiency for a pair of detection bins
    # detectionBin1 and detectionBin2 run from 0 to the number of detections_bins in each module
    values: float[detectionBin1, detectionBin2]
    # Symmetry Group Identifier (SGID)
    # This should be a number between 0 and numberOfSGIDs-1
    sgid: SGID


# Lookup table for SGIDs
# For every module pair, give the SGID. If -1, the module-pair is not in coincidence.
# Values run from -1 ... (numberOfSGIDs-1)
ModulePairSGIDLUT: int[moduleIdx1, moduleIdx2]

ModulePairEfficienciesVector: ModulePairEfficiencies*

# Component-based information on detection efficiencies
# This encodes a simple model for the detection efficiency of (true) coincidences
# consisting of the product of the efficiency of the two detection bins
# and a (geometric) component determined by their location in the two modules.
# The former are stored in detectionBinEfficiencies, and the latter in modulePairEfficienciesVector
# (a list of ModulePairEfficiencies, each entry corresponding to a module pair).
#
# To save memory, the modulePairEfficienciesVector contains only one element for each SGID.
# The SGID for a module-pair can be found in modulePairSGIDLUT.
#
# Finding the total detection efficiency therefore follows these steps in pseudo-code
# 0. obtain module-types
# 1. find modules for each detection_bin
# 2. find det_el indices "inside" each module
# 3. SGID = modulePairSGIDLUT[module_type1][module_type2][mod1, mod1]
# 4. if (SGID < 0) return 0
# 5. module_pair_efficiencies = modulePairEfficienciesVector[module_type1][module_type2][SGID]
# 6. return detectionBinEfficiencies[module_type1](detection_bin1) * detectionBinEfficiencies[module_type2](detection_bin2)
#       * module_pair_efficiencies[det_el_in_mod1, en1, det_el_in_mod2, en2]
#
# If either of the components is not present, its value is considered to be 1.
DetectionEfficiencies: !record
  fields:
    # List of detection efficiencies for every detection bin (one for each module-type).
    # Constraint: size(detectionBinEfficiencies) == ScannerInformation.numberOfReplicatedModules
    detectionBinEfficiencies: DetectionBinEfficiencies*?
    # Nested list of lookup tables for SGIDs, one for each module-type pair.
    # Also indicates if coincidences between a module-pair are recorded.
    modulePairSGIDLUT: ModulePairSGIDLUT**?
    # Nested list of all modulePairEfficienciesVectors (one for each module-type pair)
    # Constraint: size(modulePairEfficienciesVectors) == max(modulePairSGIDLUT) + 1
    modulePairEfficienciesVectors: ModulePairEfficienciesVector**?

# Constraint: size == number of all possible unique DetectionBins
SinglesAliveTimeFractions: float[detectionBin]

# Type for coincidence alive time fractions array for 2 modules in coincidence
ModuleCoincidenceAliveTimeFractions: !array
      items: float
      dimensions: [moduleId0, moduleId1]

# Type for alive-time fraction information
# (1 means no dead-time, 0 means no detected counts)
# A component-based model is used, where the total alive-time for a pair of DetectionBins
# is computed as the product of the (singles) alive-time of each detector times the
# coincidence-alive-time of the corresponding module-pair, i.e. conceptually
# aliveTimeFraction((type_of_module1, detectionBin1), (type_of_module2, detectionBin2)) =
#   singlesAliveTimeFractions[type_of_module1](detectionBin1) *
#   singlesAliveTimeFractions[type_of_module2](detectionBin2) *
#   moduleCoincidenceAliveTimeFractions[type_of_module1][type_of_module2][module(detectionBin1), module(detectionBin2)]
AliveTimeFractions: !record
  fields:
    # List of singles alive-time fractions (one for each type of module)
    singlesAliveTimeFractions: SinglesAliveTimeFractions*
    # Nested list of all-time fractions for 2 modules in coincidence.
    # If the size of an element of this nested list is (1,1), it is assumed that the corresponding alive-fraction is the same for all modules.
    # Constraint: size(moduleCoincidenceAliveTimeFractions, 0) == 1 or total number of modules of type 1
    # Constraint: size(moduleCoincidenceAliveTimeFractions, 1) == 1 or total number of modules of types 2
    # Constraint: moduleCoincidenceAliveTimeFractions[type_of_module1][type_of_module2][mod1, mod2] ==
    #   moduleCoincidenceAliveTimeFractions[type_of_module2][type_of_module1][mod2, mod1]
    moduleCoincidenceAliveTimeFractions: ModuleCoincidenceAliveTimeFractions**
