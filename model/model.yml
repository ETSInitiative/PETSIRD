# You can read more about the yardl syntax here: https://aka.ms/yardl/docs

PrdExperiment: !protocol
  sequence:
    header: Header
    # look-up table for time in the coincidence stream
    # TODO this works great for post-processing, but can yardl do this "online"? (i.e. the events are coming in: grow coincidenceTimings as necessary)
    coincidenceTimingLUT: CoincidenceTimingLUT
    events: !stream
      items: CoincidenceEvent

Subject: !record
  fields:
    name: string?
    id: string

Institution: !record
  fields:
    name: string
    address: string

# Detector ID and location. Units are in mm
# TODO: this is currently just a sample implementation with "point" detectors.
# We plan to have full shape information here.
Detector: !record
  fields:
    id: uint
    x: float
    y: float
    z: float

ScannerInformation: !record
  fields:
    modelName: string?
    detectors: Detector*

    # edge information for TOF bins in mm
    # TODO: this currently assumes equal size for each TOF bin, but some scanners "stretch" TOF bins depending on length of LOR
    tofBinEdges: !array
      items: float
      dimensions: 1
    # TOF resolution in mm
    tofResolution: float

    # edge information for energy windows in keV
    energyBinEdges: !array
      items: float
      dimensions: 1
    # FWHM of photopeak for incoming gamma of 511 keV, expressed as a ratio w.r.t. 511
    energyResolutionAt511: float

  computedFields:
    numberOfDetectors: size(detectors)
    # TODO: can we subtract 1 to get the number?
    numberP1OfTOFBins: size(tofBinEdges)
    numberP1OfEnergyBins: size(energyBinEdges)

# Items describing the exam (incomplete)
ExamInformation: !record
  fields:
    startOfAcquisition: datetime
    protocol: string?

Header: !record
  fields:
    subject: Subject
    institution: Institution
    scanner: ScannerInformation
    exam: ExamInformation?

# All information about a coincidence event specified as identifiers or indices (i.e. discretized).
# TODO: this might take up too much space, so some/all of these could be combined in a single index if necessary.
# TODO: Need to accomodate "delayed" events somewhere
CoincidenceEvent: !record
  fields:
    detector1Id: uint
    detector2Id: uint
    tofIdx: uint
    energy1Idx: uint
    energy2Idx: uint

# Time interval in milliseconds since start of acquisition
TimeInterval: !record
  fields:
     start: uint # Type could maybe be RelativeTime in the future
     stop: uint

# A sequence of time intervals (could be consecutive)
TimeFrameInformation: !record
  fields:
     timeFrames: TimeInterval*
  computedFields:
    numberOfTimeFrames: size(timeFrames)

CoincidenceTimingLUT: !record
   fields:
     # Timing information for listmode data, probably just a list of timeframes of 1 ms long, but could be non-uniform
     timeFrames: TimeFrameInformation
     # Look-up table with number of the event at the start of each time frame
     # If there is no event within a time frame, the "number" will be the same for the next time frame
     eventNumbersAtTimeFrameStart: uint64*

