# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import datetime
import enum
import types
import typing

import numpy as np
import numpy.typing as npt

from . import yardl_types as yardl
from . import _dtypes


Shape = typing.TypeVar("Shape")
Shape_NP = typing.TypeVar("Shape_NP", bound=np.generic)
T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)


class CoincidenceEvent:
    """All information about a coincidence event specified as identifiers or indices (i.e. discretized). Indices start from 0.
    TODO: this might take up too much space, so some/all of these could be combined in a single index if necessary.
    """

    detector_ids: list[yardl.UInt32]
    """the pair of detector elements"""

    tof_idx: yardl.UInt32
    """an index into the tofBinEdges field in the ScannerInformation"""

    energy_indices: list[yardl.UInt32]
    """a pair of indices into the energyBinEdges field in the ScannerInformation"""


    def __init__(self, *,
        detector_ids: typing.Optional[list[yardl.UInt32]] = None,
        tof_idx: yardl.UInt32 = 0,
        energy_indices: typing.Optional[list[yardl.UInt32]] = None,
    ):
        self.detector_ids = detector_ids if detector_ids is not None else [0] * 2
        self.tof_idx = tof_idx
        self.energy_indices = energy_indices if energy_indices is not None else [0] * 2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, CoincidenceEvent)
            and self.detector_ids == other.detector_ids
            and self.tof_idx == other.tof_idx
            and self.energy_indices == other.energy_indices
        )

    def __str__(self) -> str:
        return f"CoincidenceEvent(detectorIds={self.detector_ids}, tofIdx={self.tof_idx}, energyIndices={self.energy_indices})"

    def __repr__(self) -> str:
        return f"CoincidenceEvent(detectorIds={repr(self.detector_ids)}, tofIdx={repr(self.tof_idx)}, energyIndices={repr(self.energy_indices)})"


class SolidVolume(typing.Generic[Shape]):
    """A shape filled with a uniform material"""

    shape: Shape
    material_id: yardl.UInt32
    """identifier referring to `ScannerInformation.bulkMaterials` list"""


    def __init__(self, *,
        shape: Shape,
        material_id: yardl.UInt32 = 0,
    ):
        self.shape = shape
        self.material_id = material_id

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SolidVolume)
            and yardl.structural_equal(self.shape, other.shape)
            and self.material_id == other.material_id
        )

    def __str__(self) -> str:
        return f"SolidVolume(shape={self.shape}, materialId={self.material_id})"

    def __repr__(self) -> str:
        return f"SolidVolume(shape={repr(self.shape)}, materialId={repr(self.material_id)})"


class Coordinate:
    """3D coordinates (in mm)"""

    c: npt.NDArray[np.float32]

    def __init__(self, *,
        c: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.c = c if c is not None else np.zeros((3,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Coordinate)
            and yardl.structural_equal(self.c, other.c)
        )

    def __str__(self) -> str:
        return f"Coordinate(c={self.c})"

    def __repr__(self) -> str:
        return f"Coordinate(c={repr(self.c)})"


class BoxShape:
    """A box-shape specified by 8 corners (e.g. cuboid, wedge, etc.)
    TODO need to think about a clear definition of planes
    We do not want to have to check about intersection planes
    Potential mechanisms:
    - lexicographical ordering of corner coordinates?
    - first 4 coordinates give first plane, 5th and 6th need to define plane with first 2, etc.
    """

    corners: list[Coordinate]

    def __init__(self, *,
        corners: typing.Optional[list[Coordinate]] = None,
    ):
        self.corners = corners if corners is not None else [Coordinate() for _ in range(8)]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, BoxShape)
            and len(self.corners) == len(other.corners) and all(a == b for a, b in zip(self.corners, other.corners))
        )

    def __str__(self) -> str:
        return f"BoxShape(corners={self.corners})"

    def __repr__(self) -> str:
        return f"BoxShape(corners={repr(self.corners)})"


BoxSolidVolume = SolidVolume[BoxShape]

class AnnulusShape:
    """Annulus of certain thickness centered at [0,0,0] and oriented along the [0,0,1] axis
    in radians. An angle of 0 corresponds to the [1,0,0] axis, Pi/2 corresponds to the [0,1,0] axis.
    """

    inner_radius: yardl.Float32
    """inner radius (in mm)"""

    outer_radius: yardl.Float32
    """outer radius (in mm)"""

    thickness: yardl.Float32
    """thickness of the annulus, i.e. length along the axis (in mm)"""

    angular_range: list[yardl.Float32]
    """start-stop angle (in radians)"""


    def __init__(self, *,
        inner_radius: yardl.Float32 = 0.0,
        outer_radius: yardl.Float32 = 0.0,
        thickness: yardl.Float32 = 0.0,
        angular_range: typing.Optional[list[yardl.Float32]] = None,
    ):
        self.inner_radius = inner_radius
        self.outer_radius = outer_radius
        self.thickness = thickness
        self.angular_range = angular_range if angular_range is not None else [0.0] * 2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, AnnulusShape)
            and self.inner_radius == other.inner_radius
            and self.outer_radius == other.outer_radius
            and self.thickness == other.thickness
            and self.angular_range == other.angular_range
        )

    def __str__(self) -> str:
        return f"AnnulusShape(innerRadius={self.inner_radius}, outerRadius={self.outer_radius}, thickness={self.thickness}, angularRange={self.angular_range})"

    def __repr__(self) -> str:
        return f"AnnulusShape(innerRadius={repr(self.inner_radius)}, outerRadius={repr(self.outer_radius)}, thickness={repr(self.thickness)}, angularRange={repr(self.angular_range)})"


_T = typing.TypeVar('_T')

class GeometricShape:
    BoxShape: typing.ClassVar[type["GeometricShapeUnionCase[BoxShape]"]]
    AnnulusShape: typing.ClassVar[type["GeometricShapeUnionCase[AnnulusShape]"]]

class GeometricShapeUnionCase(GeometricShape, yardl.UnionCase[_T]):
    pass

GeometricShape.BoxShape = type("GeometricShape.BoxShape", (GeometricShapeUnionCase,), {"index": 0, "tag": "BoxShape"})
GeometricShape.AnnulusShape = type("GeometricShape.AnnulusShape", (GeometricShapeUnionCase,), {"index": 1, "tag": "AnnulusShape"})
del GeometricShapeUnionCase

GenericSolidVolume = SolidVolume[GeometricShape]

class RigidTransformation:
    """Rigid transformation, encoded via homogenous transformation
    transformed_coord = matrix * [c, 1] (where [c,1] is a column vector)
    with `c` of type `Coordinate`
    """

    matrix: npt.NDArray[np.float32]

    def __init__(self, *,
        matrix: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.matrix = matrix if matrix is not None else np.zeros((3, 4,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RigidTransformation)
            and yardl.structural_equal(self.matrix, other.matrix)
        )

    def __str__(self) -> str:
        return f"RigidTransformation(matrix={self.matrix})"

    def __repr__(self) -> str:
        return f"RigidTransformation(matrix={repr(self.matrix)})"


class ReplicatedObject(typing.Generic[T]):
    """A list of identical objects at different locations"""

    object: T
    transforms: list[RigidTransformation]
    """list of transforms
    constraint: length >= 1
    """

    ids: list[yardl.UInt32]
    """list of unique ids for every replicated solid volume
    constraint: size(transforms) == size(ids)
    """


    def __init__(self, *,
        object: T,
        transforms: typing.Optional[list[RigidTransformation]] = None,
        ids: typing.Optional[list[yardl.UInt32]] = None,
    ):
        self.object = object
        self.transforms = transforms if transforms is not None else []
        self.ids = ids if ids is not None else []

    def number_of_objects(self) -> yardl.Size:
        return len(self.transforms)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ReplicatedObject)
            and yardl.structural_equal(self.object, other.object)
            and len(self.transforms) == len(other.transforms) and all(a == b for a, b in zip(self.transforms, other.transforms))
            and self.ids == other.ids
        )

    def __str__(self) -> str:
        return f"ReplicatedObject(object={self.object}, transforms={self.transforms}, ids={self.ids})"

    def __repr__(self) -> str:
        return f"ReplicatedObject(object={repr(self.object)}, transforms={repr(self.transforms)}, ids={repr(self.ids)})"


ReplicatedBoxSolidVolume = ReplicatedObject[BoxSolidVolume]
"""A list of identical SolidVolumes<BoxShape> at different locations"""


ReplicatedGenericSolidVolume = ReplicatedObject[GenericSolidVolume]
"""A list of identical SolidVolumes<BGeometricShape> at different locations"""


class DetectorModule:
    """Top-level detector structure, consisting of one or more lists of detecting elements (or "crystals")
    This allows having different types of detecting elements (e.g. for phoswich detectors)
    TODO this could be made into a hierarchical structure
    """

    detecting_elements: list[ReplicatedBoxSolidVolume]
    detecting_element_ids: list[yardl.UInt32]
    """list of unique ids for every replicated solid volume
    constraint: size(detectingElements) == size(detectingElementsIds)
    """

    non_detecting_elements: list[ReplicatedGenericSolidVolume]
    """optional list describing shielding/optical reflectors etc"""


    def __init__(self, *,
        detecting_elements: typing.Optional[list[ReplicatedBoxSolidVolume]] = None,
        detecting_element_ids: typing.Optional[list[yardl.UInt32]] = None,
        non_detecting_elements: typing.Optional[list[ReplicatedGenericSolidVolume]] = None,
    ):
        self.detecting_elements = detecting_elements if detecting_elements is not None else []
        self.detecting_element_ids = detecting_element_ids if detecting_element_ids is not None else []
        self.non_detecting_elements = non_detecting_elements if non_detecting_elements is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DetectorModule)
            and len(self.detecting_elements) == len(other.detecting_elements) and all(a == b for a, b in zip(self.detecting_elements, other.detecting_elements))
            and self.detecting_element_ids == other.detecting_element_ids
            and len(self.non_detecting_elements) == len(other.non_detecting_elements) and all(a == b for a, b in zip(self.non_detecting_elements, other.non_detecting_elements))
        )

    def __str__(self) -> str:
        return f"DetectorModule(detectingElements={self.detecting_elements}, detectingElementIds={self.detecting_element_ids}, nonDetectingElements={self.non_detecting_elements})"

    def __repr__(self) -> str:
        return f"DetectorModule(detectingElements={repr(self.detecting_elements)}, detectingElementIds={repr(self.detecting_element_ids)}, nonDetectingElements={repr(self.non_detecting_elements)})"


ReplicatedDetectorModule = ReplicatedObject[DetectorModule]
"""A list of identical modules at different locations"""


class ScannerGeometry:
    """Full definition of the geometry of the scanner, consisting of
    one of more types of modules replicated in space and (optional) other structures (e.g. side-shielding)
    """

    replicated_modules: list[ReplicatedDetectorModule]
    """list of different types of replicated modules"""

    ids: list[yardl.UInt32]
    """list of unique ids for every replicated module
    constraint: size(replicated_modules) == size(ids)
    """

    non_detecting_volumes: typing.Optional[list[GenericSolidVolume]]
    """shielding etc"""


    def __init__(self, *,
        replicated_modules: typing.Optional[list[ReplicatedDetectorModule]] = None,
        ids: typing.Optional[list[yardl.UInt32]] = None,
        non_detecting_volumes: typing.Optional[list[GenericSolidVolume]] = None,
    ):
        self.replicated_modules = replicated_modules if replicated_modules is not None else []
        self.ids = ids if ids is not None else []
        self.non_detecting_volumes = non_detecting_volumes

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ScannerGeometry)
            and len(self.replicated_modules) == len(other.replicated_modules) and all(a == b for a, b in zip(self.replicated_modules, other.replicated_modules))
            and self.ids == other.ids
            and (other.non_detecting_volumes is None if self.non_detecting_volumes is None else (other.non_detecting_volumes is not None and len(self.non_detecting_volumes) == len(other.non_detecting_volumes) and all(a == b for a, b in zip(self.non_detecting_volumes, other.non_detecting_volumes))))
        )

    def __str__(self) -> str:
        return f"ScannerGeometry(replicatedModules={self.replicated_modules}, ids={self.ids}, nonDetectingVolumes={self.non_detecting_volumes})"

    def __repr__(self) -> str:
        return f"ScannerGeometry(replicatedModules={repr(self.replicated_modules)}, ids={repr(self.ids)}, nonDetectingVolumes={repr(self.non_detecting_volumes)})"


class Subject:
    name: typing.Optional[str]
    id: str

    def __init__(self, *,
        name: typing.Optional[str] = None,
        id: str = "",
    ):
        self.name = name
        self.id = id

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Subject)
            and self.name == other.name
            and self.id == other.id
        )

    def __str__(self) -> str:
        return f"Subject(name={self.name}, id={self.id})"

    def __repr__(self) -> str:
        return f"Subject(name={repr(self.name)}, id={repr(self.id)})"


class Institution:
    name: str
    address: str

    def __init__(self, *,
        name: str = "",
        address: str = "",
    ):
        self.name = name
        self.address = address

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Institution)
            and self.name == other.name
            and self.address == other.address
        )

    def __str__(self) -> str:
        return f"Institution(name={self.name}, address={self.address})"

    def __repr__(self) -> str:
        return f"Institution(name={repr(self.name)}, address={repr(self.address)})"


class ExamInformation:
    """Items describing the exam (incomplete)"""

    subject: Subject
    institution: Institution
    protocol: typing.Optional[str]
    start_of_acquisition: typing.Optional[yardl.DateTime]

    def __init__(self, *,
        subject: typing.Optional[Subject] = None,
        institution: typing.Optional[Institution] = None,
        protocol: typing.Optional[str] = None,
        start_of_acquisition: typing.Optional[yardl.DateTime] = None,
    ):
        self.subject = subject if subject is not None else Subject()
        self.institution = institution if institution is not None else Institution()
        self.protocol = protocol
        self.start_of_acquisition = start_of_acquisition

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ExamInformation)
            and self.subject == other.subject
            and self.institution == other.institution
            and self.protocol == other.protocol
            and self.start_of_acquisition == other.start_of_acquisition
        )

    def __str__(self) -> str:
        return f"ExamInformation(subject={self.subject}, institution={self.institution}, protocol={self.protocol}, startOfAcquisition={self.start_of_acquisition})"

    def __repr__(self) -> str:
        return f"ExamInformation(subject={repr(self.subject)}, institution={repr(self.institution)}, protocol={repr(self.protocol)}, startOfAcquisition={repr(self.start_of_acquisition)})"


class Direction:
    """3D direction vector (normalized to 1)"""

    c: npt.NDArray[np.float32]

    def __init__(self, *,
        c: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.c = c if c is not None else np.zeros((3,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Direction)
            and yardl.structural_equal(self.c, other.c)
        )

    def __str__(self) -> str:
        return f"Direction(c={self.c})"

    def __repr__(self) -> str:
        return f"Direction(c={repr(self.c)})"


class DirectionMatrix:
    """Orthonormal matrix
    direction_of_first_axis = matrix * [1, 0 ,0] (as a column vector)
    """

    matrix: npt.NDArray[np.float32]

    def __init__(self, *,
        matrix: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.matrix = matrix if matrix is not None else np.zeros((3, 3,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DirectionMatrix)
            and yardl.structural_equal(self.matrix, other.matrix)
        )

    def __str__(self) -> str:
        return f"DirectionMatrix(matrix={self.matrix})"

    def __repr__(self) -> str:
        return f"DirectionMatrix(matrix={repr(self.matrix)})"


class Atom:
    """Atom definition in terms of Z and A"""

    mass_number: yardl.UInt32
    """A"""

    atomic_number: yardl.UInt32
    """Z"""


    def __init__(self, *,
        mass_number: yardl.UInt32 = 0,
        atomic_number: yardl.UInt32 = 0,
    ):
        self.mass_number = mass_number
        self.atomic_number = atomic_number

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Atom)
            and self.mass_number == other.mass_number
            and self.atomic_number == other.atomic_number
        )

    def __str__(self) -> str:
        return f"Atom(massNumber={self.mass_number}, atomicNumber={self.atomic_number})"

    def __repr__(self) -> str:
        return f"Atom(massNumber={repr(self.mass_number)}, atomicNumber={repr(self.atomic_number)})"


class BulkMaterial:
    """Specification of materials used in the scanner.
    TODO agree with vendors if this information can be supplied and to what accuracy
    Ideally this list should be reasonably accurate to be useful for Monte Carlo simulations, but can be approximate.
    """

    id: yardl.UInt32
    """unique id that can be used to refer to the material in voxelised maps etc"""

    name: str
    """informative string, not standardised.
    Expected examples:
    detecting: BGO, LSO, LYSO, LaBr, GAGG, plastic
    non-detecting: tungsten, lead
    """

    density: yardl.Float32
    """density of the material
    Units: g/cc
    """

    atoms: list[Atom]
    """List of atoms"""

    mass_fractions: list[yardl.Float32]
    """List of massFractions for the atoms.
    constraint: sum of massFractions should be 1
    constraint:  size(atoms) == size(massFractions)
    """


    def __init__(self, *,
        id: yardl.UInt32 = 0,
        name: str = "",
        density: yardl.Float32 = 0.0,
        atoms: typing.Optional[list[Atom]] = None,
        mass_fractions: typing.Optional[list[yardl.Float32]] = None,
    ):
        self.id = id
        self.name = name
        self.density = density
        self.atoms = atoms if atoms is not None else []
        self.mass_fractions = mass_fractions if mass_fractions is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, BulkMaterial)
            and self.id == other.id
            and self.name == other.name
            and self.density == other.density
            and self.atoms == other.atoms
            and self.mass_fractions == other.mass_fractions
        )

    def __str__(self) -> str:
        return f"BulkMaterial(id={self.id}, name={self.name}, density={self.density}, atoms={self.atoms}, massFractions={self.mass_fractions})"

    def __repr__(self) -> str:
        return f"BulkMaterial(id={repr(self.id)}, name={repr(self.name)}, density={repr(self.density)}, atoms={repr(self.atoms)}, massFractions={repr(self.mass_fractions)})"


class CoincidencePolicy(yardl.OutOfRangeEnum):
    """Type definition for how to encode how the scanner handles multiple coincidences when recording the prompts.
    Due to various effects (such as high count rate, prompt gammas), it is possible that multiple single
    events are detected within the coincidence window. This type encodes some different ways
    that this multiple events are handled, and recorded in the coincidence stream.
    """

    REJECT_MULTIPLES = 0
    """multiples will be rejected"""

    STORE_MULTIPLES_AS_PAIRS = 1
    """multiples will be stored as a sequence of pairs, e.g. a triple leads to 3 pairs"""

    OTHER = 2
    """other options, to be listed in the future"""


class ScannerInformation:
    model_name: str
    scanner_geometry: ScannerGeometry
    """Geometric information for all detector elements
    All coordinates are in the PET gantry coordinate system.
    """

    bulk_materials: list[BulkMaterial]
    """List of materials present in the scanner geometry. The `material_id`s there will refer to the
    identifiers in this list below.
    """

    gantry_alignment: typing.Optional[RigidTransformation]
    """Fixed transformation to reference location for this scanner.
    This field can be used to encode alignment with the CT or MRI gantry for instance.
    The transformation should convert from the PET gantry coordinate system to the reference.
    An empty field implies the identity transformation.
    """

    tof_bin_edges: npt.NDArray[np.float32]
    """Edge information for TOF bins in mm (given as from first to last edge, so there is one more edge than the number of bins)
    0 corresponds to the same arrival time. Negative numbers indicate that the first detector detected first.
    For instance, a coincidence event is stored as 2 detectorIds, denoting the arrival time at the first
    detector t1 and the arrival time at the second detector t2, we store (t1-t2)*c/2.
    Note: for non-TOF scanners, this defines the coincidence window
    TODO: this currently assumes equal size for each TOF bin, but some scanners "stretch" TOF bins depending on length of LOR
    """

    tof_resolution: yardl.Float32
    """TOF resolution (as FWHM) in mm
    Scanner coincidence timing resolution (CTR) without tof-binning
    """

    energy_bin_edges: npt.NDArray[np.float32]
    """Edge information for energy windows in keV (given as from first to last edge, so there is one more edge than the number of bins)"""

    energy_resolution_at_511: yardl.Float32
    """FWHM of photopeak for incoming gamma of 511 keV, expressed as a ratio w.r.t. 511"""

    event_time_block_duration: yardl.UInt32
    """duration of each event time block in ms"""

    coincidence_policy: CoincidencePolicy
    """Encode how the scanner handles multiple coincidences"""


    def __init__(self, *,
        model_name: str = "",
        scanner_geometry: typing.Optional[ScannerGeometry] = None,
        bulk_materials: typing.Optional[list[BulkMaterial]] = None,
        gantry_alignment: typing.Optional[RigidTransformation] = None,
        tof_bin_edges: typing.Optional[npt.NDArray[np.float32]] = None,
        tof_resolution: yardl.Float32 = 0.0,
        energy_bin_edges: typing.Optional[npt.NDArray[np.float32]] = None,
        energy_resolution_at_511: yardl.Float32 = 0.0,
        event_time_block_duration: yardl.UInt32 = 0,
        coincidence_policy: CoincidencePolicy = CoincidencePolicy.REJECT_MULTIPLES,
    ):
        self.model_name = model_name
        self.scanner_geometry = scanner_geometry if scanner_geometry is not None else ScannerGeometry()
        self.bulk_materials = bulk_materials if bulk_materials is not None else []
        self.gantry_alignment = gantry_alignment
        self.tof_bin_edges = tof_bin_edges if tof_bin_edges is not None else np.zeros((0), dtype=np.dtype(np.float32))
        self.tof_resolution = tof_resolution
        self.energy_bin_edges = energy_bin_edges if energy_bin_edges is not None else np.zeros((0), dtype=np.dtype(np.float32))
        self.energy_resolution_at_511 = energy_resolution_at_511
        self.event_time_block_duration = event_time_block_duration
        self.coincidence_policy = coincidence_policy

    def number_of_tof_bins(self) -> yardl.Size:
        return self.tof_bin_edges.size - 1

    def number_of_energy_bins(self) -> yardl.Size:
        return self.energy_bin_edges.size - 1

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ScannerInformation)
            and self.model_name == other.model_name
            and self.scanner_geometry == other.scanner_geometry
            and self.bulk_materials == other.bulk_materials
            and (other.gantry_alignment is None if self.gantry_alignment is None else (other.gantry_alignment is not None and self.gantry_alignment == other.gantry_alignment))
            and yardl.structural_equal(self.tof_bin_edges, other.tof_bin_edges)
            and self.tof_resolution == other.tof_resolution
            and yardl.structural_equal(self.energy_bin_edges, other.energy_bin_edges)
            and self.energy_resolution_at_511 == other.energy_resolution_at_511
            and self.event_time_block_duration == other.event_time_block_duration
            and self.coincidence_policy == other.coincidence_policy
        )

    def __str__(self) -> str:
        return f"ScannerInformation(modelName={self.model_name}, scannerGeometry={self.scanner_geometry}, bulkMaterials={self.bulk_materials}, gantryAlignment={self.gantry_alignment}, tofBinEdges={self.tof_bin_edges}, tofResolution={self.tof_resolution}, energyBinEdges={self.energy_bin_edges}, energyResolutionAt511={self.energy_resolution_at_511}, eventTimeBlockDuration={self.event_time_block_duration}, coincidencePolicy={self.coincidence_policy})"

    def __repr__(self) -> str:
        return f"ScannerInformation(modelName={repr(self.model_name)}, scannerGeometry={repr(self.scanner_geometry)}, bulkMaterials={repr(self.bulk_materials)}, gantryAlignment={repr(self.gantry_alignment)}, tofBinEdges={repr(self.tof_bin_edges)}, tofResolution={repr(self.tof_resolution)}, energyBinEdges={repr(self.energy_bin_edges)}, energyResolutionAt511={repr(self.energy_resolution_at_511)}, eventTimeBlockDuration={repr(self.event_time_block_duration)}, coincidencePolicy={repr(self.coincidence_policy)})"


class Header:
    scanner: ScannerInformation
    exam: typing.Optional[ExamInformation]

    def __init__(self, *,
        scanner: typing.Optional[ScannerInformation] = None,
        exam: typing.Optional[ExamInformation] = None,
    ):
        self.scanner = scanner if scanner is not None else ScannerInformation()
        self.exam = exam

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Header)
            and self.scanner == other.scanner
            and self.exam == other.exam
        )

    def __str__(self) -> str:
        return f"Header(scanner={self.scanner}, exam={self.exam})"

    def __repr__(self) -> str:
        return f"Header(scanner={repr(self.scanner)}, exam={repr(self.exam)})"


class TripleEvent:
    """All information about a triple event specified as identifiers or indices (i.e. discretized)."""

    detector_ids: list[yardl.UInt32]
    tof_indices: list[yardl.UInt32]
    """timing differences (converted to mm) w.r.t. first event, stored as
    indices into the tofBinEdges field in the ScannerInformation
    Note: only 2, corresponding to the arrival time differences of the second and third detectorId
    listed w.r.t. the first detectorId
    """

    energy_indices: list[yardl.UInt32]
    """indices for each single event into the energyBinEdges field in the ScannerInformation"""


    def __init__(self, *,
        detector_ids: typing.Optional[list[yardl.UInt32]] = None,
        tof_indices: typing.Optional[list[yardl.UInt32]] = None,
        energy_indices: typing.Optional[list[yardl.UInt32]] = None,
    ):
        self.detector_ids = detector_ids if detector_ids is not None else [0] * 3
        self.tof_indices = tof_indices if tof_indices is not None else [0] * 2
        self.energy_indices = energy_indices if energy_indices is not None else [0] * 3

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TripleEvent)
            and self.detector_ids == other.detector_ids
            and self.tof_indices == other.tof_indices
            and self.energy_indices == other.energy_indices
        )

    def __str__(self) -> str:
        return f"TripleEvent(detectorIds={self.detector_ids}, tofIndices={self.tof_indices}, energyIndices={self.energy_indices})"

    def __repr__(self) -> str:
        return f"TripleEvent(detectorIds={repr(self.detector_ids)}, tofIndices={repr(self.tof_indices)}, energyIndices={repr(self.energy_indices)})"


class EventTimeBlock:
    start: yardl.UInt32
    """start time since ExamInformation.startOfAcquisition in ms
    Note: duration is given by ScannerInformation.eventTimeBlockDuration
    """

    prompt_events: list[CoincidenceEvent]
    """TODO encode end time?
    list of prompts in this time block
    TODO might be better to use !array
    """

    delayed_events: typing.Optional[list[CoincidenceEvent]]
    """optional list of delayed coincidences in this time block"""

    triple_events: typing.Optional[list[TripleEvent]]
    """optional list of triple coincidences in this time block"""


    def __init__(self, *,
        start: yardl.UInt32 = 0,
        prompt_events: typing.Optional[list[CoincidenceEvent]] = None,
        delayed_events: typing.Optional[list[CoincidenceEvent]] = None,
        triple_events: typing.Optional[list[TripleEvent]] = None,
    ):
        self.start = start
        self.prompt_events = prompt_events if prompt_events is not None else []
        self.delayed_events = delayed_events
        self.triple_events = triple_events

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, EventTimeBlock)
            and self.start == other.start
            and self.prompt_events == other.prompt_events
            and self.delayed_events == other.delayed_events
            and self.triple_events == other.triple_events
        )

    def __str__(self) -> str:
        return f"EventTimeBlock(start={self.start}, promptEvents={self.prompt_events}, delayedEvents={self.delayed_events}, tripleEvents={self.triple_events})"

    def __repr__(self) -> str:
        return f"EventTimeBlock(start={repr(self.start)}, promptEvents={repr(self.prompt_events)}, delayedEvents={repr(self.delayed_events)}, tripleEvents={repr(self.triple_events)})"


class ExternalSignalTimeBlock:
    start: yardl.UInt32
    """start time since ExamInformation.startOfAcquisition in ms"""

    signal_id: yardl.UInt32
    """refer to ExternalSignalType.id"""

    signal_values: list[yardl.Float32]
    """Note for triggers, this field is to be ignored"""


    def __init__(self, *,
        start: yardl.UInt32 = 0,
        signal_id: yardl.UInt32 = 0,
        signal_values: typing.Optional[list[yardl.Float32]] = None,
    ):
        self.start = start
        self.signal_id = signal_id
        self.signal_values = signal_values if signal_values is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ExternalSignalTimeBlock)
            and self.start == other.start
            and self.signal_id == other.signal_id
            and self.signal_values == other.signal_values
        )

    def __str__(self) -> str:
        return f"ExternalSignalTimeBlock(start={self.start}, signalID={self.signal_id}, signalValues={self.signal_values})"

    def __repr__(self) -> str:
        return f"ExternalSignalTimeBlock(start={repr(self.start)}, signalID={repr(self.signal_id)}, signalValues={repr(self.signal_values)})"


class BedMovementTimeBlock:
    start: yardl.UInt32
    """start time since ExamInformation.startOfAcquisition in ms"""

    transform: RigidTransformation

    def __init__(self, *,
        start: yardl.UInt32 = 0,
        transform: typing.Optional[RigidTransformation] = None,
    ):
        self.start = start
        self.transform = transform if transform is not None else RigidTransformation()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, BedMovementTimeBlock)
            and self.start == other.start
            and self.transform == other.transform
        )

    def __str__(self) -> str:
        return f"BedMovementTimeBlock(start={self.start}, transform={self.transform})"

    def __repr__(self) -> str:
        return f"BedMovementTimeBlock(start={repr(self.start)}, transform={repr(self.transform)})"


class GantryMovementTimeBlock:
    start: yardl.UInt32
    """start time since ExamInformation.startOfAcquisition in ms"""

    transform: RigidTransformation

    def __init__(self, *,
        start: yardl.UInt32 = 0,
        transform: typing.Optional[RigidTransformation] = None,
    ):
        self.start = start
        self.transform = transform if transform is not None else RigidTransformation()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GantryMovementTimeBlock)
            and self.start == other.start
            and self.transform == other.transform
        )

    def __str__(self) -> str:
        return f"GantryMovementTimeBlock(start={self.start}, transform={self.transform})"

    def __repr__(self) -> str:
        return f"GantryMovementTimeBlock(start={repr(self.start)}, transform={repr(self.transform)})"


class TimeBlock:
    EventTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[EventTimeBlock]"]]
    ExternalSignalTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[ExternalSignalTimeBlock]"]]
    BedMovementTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[BedMovementTimeBlock]"]]
    GantryMovementTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[GantryMovementTimeBlock]"]]

class TimeBlockUnionCase(TimeBlock, yardl.UnionCase[_T]):
    pass

TimeBlock.EventTimeBlock = type("TimeBlock.EventTimeBlock", (TimeBlockUnionCase,), {"index": 0, "tag": "EventTimeBlock"})
TimeBlock.ExternalSignalTimeBlock = type("TimeBlock.ExternalSignalTimeBlock", (TimeBlockUnionCase,), {"index": 1, "tag": "ExternalSignalTimeBlock"})
TimeBlock.BedMovementTimeBlock = type("TimeBlock.BedMovementTimeBlock", (TimeBlockUnionCase,), {"index": 2, "tag": "BedMovementTimeBlock"})
TimeBlock.GantryMovementTimeBlock = type("TimeBlock.GantryMovementTimeBlock", (TimeBlockUnionCase,), {"index": 3, "tag": "GantryMovementTimeBlock"})
del TimeBlockUnionCase

class ExternalSignalTypeEnum(yardl.OutOfRangeEnum):
    ECG_TRACE = 0
    ECG_TRIGGER = 1
    RESP_TRACE = 2
    RESP_TRIGGER = 3
    OTHER_MOTION_SIGNAL = 4
    OTHER_MOTION_TRIGGER = 5
    EXTERNAL_SYNC = 6
    OTHER = 7
    """other options, to be listed in the future"""


class ExternalSignalType:
    type: ExternalSignalTypeEnum
    description: str
    id: yardl.UInt32

    def __init__(self, *,
        type: ExternalSignalTypeEnum = ExternalSignalTypeEnum.ECG_TRACE,
        description: str = "",
        id: yardl.UInt32 = 0,
    ):
        self.type = type
        self.description = description
        self.id = id

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ExternalSignalType)
            and self.type == other.type
            and self.description == other.description
            and self.id == other.id
        )

    def __str__(self) -> str:
        return f"ExternalSignalType(type={self.type}, description={self.description}, id={self.id})"

    def __repr__(self) -> str:
        return f"ExternalSignalType(type={repr(self.type)}, description={repr(self.description)}, id={repr(self.id)})"


class TimeInterval:
    """Time interval in milliseconds since start of acquisition"""

    start: yardl.UInt32
    stop: yardl.UInt32

    def __init__(self, *,
        start: yardl.UInt32 = 0,
        stop: yardl.UInt32 = 0,
    ):
        self.start = start
        self.stop = stop

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TimeInterval)
            and self.start == other.start
            and self.stop == other.stop
        )

    def __str__(self) -> str:
        return f"TimeInterval(start={self.start}, stop={self.stop})"

    def __repr__(self) -> str:
        return f"TimeInterval(start={repr(self.start)}, stop={repr(self.stop)})"


class TimeFrameInformation:
    """A sequence of time intervals (could be consecutive)"""

    time_frames: list[TimeInterval]

    def __init__(self, *,
        time_frames: typing.Optional[list[TimeInterval]] = None,
    ):
        self.time_frames = time_frames if time_frames is not None else []

    def number_of_time_frames(self) -> yardl.Size:
        return len(self.time_frames)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TimeFrameInformation)
            and self.time_frames == other.time_frames
        )

    def __str__(self) -> str:
        return f"TimeFrameInformation(timeFrames={self.time_frames})"

    def __repr__(self) -> str:
        return f"TimeFrameInformation(timeFrames={repr(self.time_frames)})"


def _mk_get_dtype():
    dtype_map: dict[typing.Union[type, types.GenericAlias], typing.Union[np.dtype[typing.Any], typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map.setdefault(CoincidenceEvent, np.dtype([('detector_ids', np.dtype(np.uint32), (2,)), ('tof_idx', np.dtype(np.uint32)), ('energy_indices', np.dtype(np.uint32), (2,))], align=True))
    dtype_map.setdefault(SolidVolume, lambda type_args: np.dtype([('shape', get_dtype(type_args[0])), ('material_id', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(Coordinate, np.dtype([('c', np.dtype(np.float32), (3,))], align=True))
    dtype_map.setdefault(BoxShape, np.dtype([('corners', get_dtype(Coordinate), (8,))], align=True))
    dtype_map.setdefault(BoxSolidVolume, get_dtype(types.GenericAlias(SolidVolume, (BoxShape,))))
    dtype_map.setdefault(AnnulusShape, np.dtype([('inner_radius', np.dtype(np.float32)), ('outer_radius', np.dtype(np.float32)), ('thickness', np.dtype(np.float32)), ('angular_range', np.dtype(np.float32), (2,))], align=True))
    dtype_map.setdefault(GeometricShape, np.dtype(np.object_))
    dtype_map.setdefault(GenericSolidVolume, get_dtype(types.GenericAlias(SolidVolume, (GeometricShape,))))
    dtype_map.setdefault(RigidTransformation, np.dtype([('matrix', np.dtype(np.float32), (3, 4,))], align=True))
    dtype_map.setdefault(ReplicatedObject, lambda type_args: np.dtype([('object', get_dtype(type_args[0])), ('transforms', np.dtype(np.object_)), ('ids', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(ReplicatedBoxSolidVolume, get_dtype(types.GenericAlias(ReplicatedObject, (BoxSolidVolume,))))
    dtype_map.setdefault(ReplicatedGenericSolidVolume, get_dtype(types.GenericAlias(ReplicatedObject, (GenericSolidVolume,))))
    dtype_map.setdefault(DetectorModule, np.dtype([('detecting_elements', np.dtype(np.object_)), ('detecting_element_ids', np.dtype(np.object_)), ('non_detecting_elements', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(ReplicatedDetectorModule, get_dtype(types.GenericAlias(ReplicatedObject, (DetectorModule,))))
    dtype_map.setdefault(ScannerGeometry, np.dtype([('replicated_modules', np.dtype(np.object_)), ('ids', np.dtype(np.object_)), ('non_detecting_volumes', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(Subject, np.dtype([('name', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('id', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(Institution, np.dtype([('name', np.dtype(np.object_)), ('address', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(ExamInformation, np.dtype([('subject', get_dtype(Subject)), ('institution', get_dtype(Institution)), ('protocol', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('start_of_acquisition', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.datetime64))], align=True))], align=True))
    dtype_map.setdefault(Direction, np.dtype([('c', np.dtype(np.float32), (3,))], align=True))
    dtype_map.setdefault(DirectionMatrix, np.dtype([('matrix', np.dtype(np.float32), (3, 3,))], align=True))
    dtype_map.setdefault(Atom, np.dtype([('mass_number', np.dtype(np.uint32)), ('atomic_number', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(BulkMaterial, np.dtype([('id', np.dtype(np.uint32)), ('name', np.dtype(np.object_)), ('density', np.dtype(np.float32)), ('atoms', np.dtype(np.object_)), ('mass_fractions', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(CoincidencePolicy, np.dtype(np.int32))
    dtype_map.setdefault(ScannerInformation, np.dtype([('model_name', np.dtype(np.object_)), ('scanner_geometry', get_dtype(ScannerGeometry)), ('bulk_materials', np.dtype(np.object_)), ('gantry_alignment', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(RigidTransformation))], align=True)), ('tof_bin_edges', np.dtype(np.object_)), ('tof_resolution', np.dtype(np.float32)), ('energy_bin_edges', np.dtype(np.object_)), ('energy_resolution_at_511', np.dtype(np.float32)), ('event_time_block_duration', np.dtype(np.uint32)), ('coincidence_policy', get_dtype(CoincidencePolicy))], align=True))
    dtype_map.setdefault(Header, np.dtype([('scanner', get_dtype(ScannerInformation)), ('exam', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(ExamInformation))], align=True))], align=True))
    dtype_map.setdefault(TripleEvent, np.dtype([('detector_ids', np.dtype(np.uint32), (3,)), ('tof_indices', np.dtype(np.uint32), (2,)), ('energy_indices', np.dtype(np.uint32), (3,))], align=True))
    dtype_map.setdefault(EventTimeBlock, np.dtype([('start', np.dtype(np.uint32)), ('prompt_events', np.dtype(np.object_)), ('delayed_events', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('triple_events', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(ExternalSignalTimeBlock, np.dtype([('start', np.dtype(np.uint32)), ('signal_id', np.dtype(np.uint32)), ('signal_values', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(BedMovementTimeBlock, np.dtype([('start', np.dtype(np.uint32)), ('transform', get_dtype(RigidTransformation))], align=True))
    dtype_map.setdefault(GantryMovementTimeBlock, np.dtype([('start', np.dtype(np.uint32)), ('transform', get_dtype(RigidTransformation))], align=True))
    dtype_map.setdefault(TimeBlock, np.dtype(np.object_))
    dtype_map.setdefault(ExternalSignalTypeEnum, np.dtype(np.int32))
    dtype_map.setdefault(ExternalSignalType, np.dtype([('type', get_dtype(ExternalSignalTypeEnum)), ('description', np.dtype(np.object_)), ('id', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(TimeInterval, np.dtype([('start', np.dtype(np.uint32)), ('stop', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(TimeFrameInformation, np.dtype([('time_frames', np.dtype(np.object_))], align=True))

    return get_dtype

get_dtype = _mk_get_dtype()

